{
  "version": "1.0.0",
  "last_updated": "2026-01-25",
  "purpose": "Detailed breakdown of every component's internal structure, methods, parameters, dependencies, and interfaces",
  "sections": {
    "1_controllers": {
      "number": "1",
      "name": "Controllers",
      "components": {
        "1.1_basecontroller": {
          "number": "1.1",
          "name": "BaseController",
          "file": "src/Controllers/BaseController.php",
          "purpose": "Base class providing standardized response methods",
          "dependencies": [
            "ResponseFactoryInterface",
            "App\\Utilities\\ResponseFactory",
            "App\\Utilities\\ErrorFactory"
          ],
          "methods": [
            {
              "signature": "__construct(ResponseFactoryInterface $responseFactory)",
              "purpose": "Initialize controller with response factory",
              "parameters": [
                {
                  "name": "$responseFactory",
                  "description": "PSR-7 response factory"
                }
              ],
              "returns": "void",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [],
              "exception_handling": [],
              "side_effects": "None",
              "throws": []
            },
            {
              "signature": "single(mixed $data, int $statusCode = 200): ResponseInterface",
              "purpose": "Create single object response",
              "parameters": [
                {
                  "name": "$data",
                  "description": "Response data (wrapped in `data` key)"
                },
                {
                  "name": "$statusCode",
                  "description": "HTTP status code (default: 200)"
                }
              ],
              "returns": "`ResponseInterface` with JSON body `{\"data\": {...}}`",
              "uses": "ResponseFactoryUtil::single()",
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [],
              "exception_handling": [],
              "side_effects": null,
              "throws": []
            },
            {
              "signature": "list(array $data, int $statusCode = 200): ResponseInterface",
              "purpose": "Create list response",
              "parameters": [
                {
                  "name": "$data",
                  "description": "Array of items (wrapped in `data` key)"
                },
                {
                  "name": "$statusCode",
                  "description": "HTTP status code (default: 200)"
                }
              ],
              "returns": "`ResponseInterface` with JSON body `{\"data\": [...]}`",
              "uses": "ResponseFactoryUtil::list()",
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [],
              "exception_handling": [],
              "side_effects": null,
              "throws": []
            },
            {
              "signature": "paginated(array $data, int $limit, ?string $cursor = null, int $statusCode = 200): ResponseInterface",
              "purpose": "Create paginated list response",
              "parameters": [
                {
                  "name": "$data",
                  "description": "Array of items"
                },
                {
                  "name": "$limit",
                  "description": "Number of items per page"
                },
                {
                  "name": "$cursor",
                  "description": "Opaque cursor value for next page (optional)"
                },
                {
                  "name": "$statusCode",
                  "description": "HTTP status code (default: 200)"
                }
              ],
              "returns": "`ResponseInterface` with JSON body `{\"data\": [...], \"paging\": {\"limit\": N, \"cursor\": \"...\"}}`",
              "uses": "ResponseFactoryUtil::paginated()",
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [],
              "exception_handling": [],
              "side_effects": null,
              "throws": []
            },
            {
              "signature": "created(mixed $data): ResponseInterface",
              "purpose": "Create 201 Created response",
              "parameters": [
                {
                  "name": "$data",
                  "description": "Created resource data"
                }
              ],
              "returns": "`ResponseInterface` with status 201 and JSON body `{\"data\": {...}}`",
              "uses": "ResponseFactoryUtil::created()",
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [],
              "exception_handling": [],
              "side_effects": null,
              "throws": []
            },
            {
              "signature": "noContent(): ResponseInterface",
              "purpose": "Create 204 No Content response",
              "parameters": [],
              "returns": "`ResponseInterface` with status 204 and empty body",
              "uses": "ResponseFactoryUtil::noContent()",
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [],
              "exception_handling": [],
              "side_effects": null,
              "throws": []
            },
            {
              "signature": "error(string $code, string $message, array $details = [], ?int $statusCode = null): ResponseInterface",
              "purpose": "Create JSON error response",
              "parameters": [
                {
                  "name": "$code",
                  "description": "Error code (from ErrorFactory constants)"
                },
                {
                  "name": "$message",
                  "description": "Error message"
                },
                {
                  "name": "$details",
                  "description": "Additional error details (default: [])"
                },
                {
                  "name": "$statusCode",
                  "description": "HTTP status code (optional, mapped from error code if not provided)"
                }
              ],
              "returns": "`ResponseInterface` with JSON body `{\"error\": {\"code\": \"...\", \"message\": \"...\", \"details\": {...}}}`",
              "uses": "ErrorFactory::create()",
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [],
              "exception_handling": [],
              "side_effects": null,
              "throws": []
            }
          ]
        },
        "1.2_gateway_postcontroller": {
          "number": "1.2",
          "name": "Gateway PostController",
          "file": "src/Controllers/Gateway/PostController.php",
          "purpose": "Handle post creation and access management endpoints for Gateway JSON surface",
          "dependencies": [
            "ResponseFactoryInterface",
            "PostService"
          ],
          "methods": [
            {
              "signature": "__construct(ResponseFactoryInterface $responseFactory, PostService $postService)",
              "purpose": "Initialize controller",
              "parameters": [
                {
                  "name": "$responseFactory",
                  "description": "PSR-7 response factory"
                },
                {
                  "name": "$postService",
                  "description": "Post service instance"
                }
              ],
              "returns": "void",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [],
              "exception_handling": [],
              "side_effects": "Calls `parent::__construct($responseFactory)`",
              "throws": []
            },
            {
              "signature": "create(ServerRequestInterface $request, ResponseInterface $response): ResponseInterface",
              "purpose": "Create a new post",
              "parameters": [],
              "returns": "`ResponseInterface` with status 201 and JSON body `{\"data\": {post object}}`",
              "uses": null,
              "endpoint": "POST /api/posts",
              "auth": "Key JWT (`typ=key`)",
              "required_permission": "posts:create",
              "required_mask": null,
              "request_attributes_used": [
                "key_id (from JwtKeyMiddleware)"
              ],
              "route_parameters": [],
              "request_body_expected": [
                "content (string, required, 1-10000 chars)",
                "title (string, optional, 1-255 chars)"
              ],
              "query_parameters": [],
              "process": [
                "1. Extract `key_id` from request attributes",
                "2. Validate `key_id` exists",
                "3. Parse request body",
                "4. Validate `content` field exists and is string",
                "5. Call `PostService::createPost($keyIdHex32, $content, $title)`",
                "6. Return 201 Created response with post data"
              ],
              "exception_handling": [
                "ForbiddenException → 403 Forbidden with required permissions/mask",
                "InvalidArgumentException → 400 Bad Request"
              ],
              "side_effects": null,
              "throws": []
            },
            {
              "signature": "grantAccess(ServerRequestInterface $request, ResponseInterface $response): ResponseInterface",
              "purpose": "Grant access to a post",
              "parameters": [],
              "returns": "`ResponseInterface` with status 201 and JSON body `{\"data\": {access object}}`",
              "uses": null,
              "endpoint": "POST /api/posts/{postId}/access",
              "auth": "Key JWT (`typ=key`)",
              "required_permission": "posts:access:manage",
              "required_mask": "MANAGE_ACCESS",
              "request_attributes_used": [
                "key_id (from JwtKeyMiddleware)",
                "permissions (from JwtKeyMiddleware)"
              ],
              "route_parameters": [
                "postId (hex32)"
              ],
              "request_body_expected": [
                "target_type (string, required, 'key' or 'group')",
                "target_id (string, required, hex32)",
                "permission_mask (int, required, valid bitmask)"
              ],
              "query_parameters": [],
              "process": [
                "1. Extract `key_id` and `permissions` from request attributes",
                "2. Validate `key_id` exists",
                "3. Extract `postId` from route parameters",
                "4. Validate `postId` exists and is string",
                "5. Parse request body",
                "6. Validate `target_type`, `target_id`, `permission_mask` fields",
                "7. Call `PostService::grantAccess($postIdHex32, $keyIdHex32, $permissions, $targetType, $targetIdHex32, $permissionMask)`",
                "8. Return 201 Created response with access grant data"
              ],
              "exception_handling": [
                "NotFoundException → 404 Not Found",
                "ForbiddenException → 403 Forbidden with required permissions/mask",
                "InvalidArgumentException → 400 Bad Request"
              ],
              "side_effects": null,
              "throws": []
            },
            {
              "signature": "list(ServerRequestInterface $request, ResponseInterface $response): ResponseInterface",
              "purpose": "List posts accessible to a key",
              "parameters": [],
              "returns": "`ResponseInterface` with status 200 and JSON body `{\"data\": [post objects]}`",
              "uses": null,
              "endpoint": "GET /api/posts",
              "auth": "Key JWT (`typ=key`)",
              "required_permission": "posts:read",
              "required_mask": null,
              "request_attributes_used": [
                "key_id (from JwtKeyMiddleware)",
                "permissions (from JwtKeyMiddleware)"
              ],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [
                "limit (int, optional, default: 20, max: 100)",
                "before_id (string, optional, hex32 cursor)"
              ],
              "process": [
                "1. Extract `key_id` and `permissions` from request attributes",
                "2. Validate `key_id` exists",
                "3. Verify `posts:read` permission in `$permissions` array",
                "4. Parse query parameters (`limit`, `before_id`)",
                "5. Normalize `limit` (default: 20, clamp to 1-100)",
                "6. Call `PostService::listPosts($keyIdHex32, $permissions, $limit, $beforeId)`",
                "7. Return 200 OK response with list of posts"
              ],
              "exception_handling": [],
              "side_effects": null,
              "throws": []
            },
            {
              "signature": "get(ServerRequestInterface $request, ResponseInterface $response): ResponseInterface",
              "purpose": "Get post details",
              "parameters": [],
              "returns": "`ResponseInterface` with status 200 and JSON body `{\"data\": {post object}}`",
              "uses": null,
              "endpoint": "GET /api/posts/{postId}",
              "auth": "Key JWT (`typ=key`)",
              "required_permission": "posts:read",
              "required_mask": "VIEW",
              "request_attributes_used": [
                "key_id (from JwtKeyMiddleware)",
                "permissions (from JwtKeyMiddleware)"
              ],
              "route_parameters": [
                "postId (hex32)"
              ],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [
                "1. Extract `key_id` and `permissions` from request attributes",
                "2. Validate `key_id` exists",
                "3. Extract `postId` from route parameters",
                "4. Validate `postId` exists and is string",
                "5. Call `PostService::getPost($postIdHex32, $keyIdHex32, $permissions)`",
                "6. Return 200 OK response with post data"
              ],
              "exception_handling": [
                "NotFoundException → 404 Not Found",
                "ForbiddenException → 403 Forbidden with required permissions/mask"
              ],
              "side_effects": null,
              "throws": []
            },
            {
              "signature": "revokeAccess(ServerRequestInterface $request, ResponseInterface $response): ResponseInterface",
              "purpose": "Revoke access to a post",
              "parameters": [],
              "returns": "`ResponseInterface` with status 204 and empty body",
              "uses": null,
              "endpoint": "DELETE /api/posts/{postId}/access/{targetType}/{targetId}",
              "auth": "Key JWT (`typ=key`)",
              "required_permission": "posts:access:manage",
              "required_mask": "MANAGE_ACCESS",
              "request_attributes_used": [
                "key_id (from JwtKeyMiddleware)",
                "permissions (from JwtKeyMiddleware)"
              ],
              "route_parameters": [
                "postId (hex32)",
                "targetType (string, 'key' or 'group')",
                "targetId (hex32)"
              ],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [
                "1. Extract `key_id` and `permissions` from request attributes",
                "2. Validate `key_id` exists",
                "3. Extract route parameters (`postId`, `targetType`, `targetId`)",
                "4. Validate all route parameters exist and are strings",
                "5. Call `PostService::revokeAccess($postIdHex32, $keyIdHex32, $permissions, $targetType, $targetIdHex32)`",
                "6. Return 204 No Content response"
              ],
              "exception_handling": [
                "NotFoundException → 404 Not Found",
                "ForbiddenException → 403 Forbidden with required permissions/mask",
                "InvalidArgumentException → 400 Bad Request"
              ],
              "side_effects": null,
              "throws": []
            }
          ]
        },
        "1.3_gateway_feedcontroller": {
          "number": "1.3",
          "name": "Gateway FeedController",
          "file": "src/Controllers/Gateway/FeedController.php",
          "purpose": "Handle feed endpoints for Gateway JSON surface",
          "dependencies": [
            "ResponseFactoryInterface",
            "FeedService"
          ],
          "methods": [
            {
              "signature": "__construct(ResponseFactoryInterface $responseFactory, FeedService $feedService)",
              "purpose": "Initialize controller",
              "parameters": [
                {
                  "name": "$responseFactory",
                  "description": "PSR-7 response factory"
                },
                {
                  "name": "$feedService",
                  "description": "Feed service instance"
                }
              ],
              "returns": "void",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [],
              "exception_handling": [],
              "side_effects": "Calls `parent::__construct($responseFactory)`",
              "throws": []
            },
            {
              "signature": "getUseFeed(ServerRequestInterface $request, ResponseInterface $response): ResponseInterface",
              "purpose": "Get Use Key feed",
              "parameters": [],
              "returns": "`ResponseInterface` with status 200 and JSON body `{\"data\": {\"data\": [posts], \"paging\": {...}}}`",
              "uses": null,
              "endpoint": "GET /api/feed/use/{useKeyId}",
              "auth": "Key JWT (`typ=key`)",
              "required_permission": "posts:read",
              "required_mask": null,
              "request_attributes_used": [
                "key_id (from JwtKeyMiddleware, stored as $jwtKeyIdHex32)",
                "permissions (from JwtKeyMiddleware)"
              ],
              "route_parameters": [
                "useKeyId (hex32)"
              ],
              "request_body_expected": [],
              "query_parameters": [
                "limit (int, optional, default: 20, max: 100)",
                "before_id (string, optional, hex32 cursor for older posts)",
                "since_id (string, optional, hex32 cursor for newer posts)"
              ],
              "process": [
                "1. Extract `key_id` and `permissions` from request attributes",
                "2. Validate `key_id` exists",
                "3. Extract `useKeyId` from route parameters",
                "4. Validate `useKeyId` exists and is string",
                "5. Parse query parameters (`limit`, `before_id`, `since_id`)",
                "6. Validate that `before_id` and `since_id` are not both provided",
                "7. Call `FeedService::getUseKeyFeed($useKeyIdHex32, $jwtKeyIdHex32, $permissions, $limit, $beforeIdHex32, $sinceIdHex32)`",
                "8. Return 200 OK response with feed data"
              ],
              "exception_handling": [
                "NotFoundException → 404 Not Found (includes path guard mismatch)",
                "ForbiddenException → 403 Forbidden with required permissions",
                "InvalidArgumentException → 400 Bad Request"
              ],
              "side_effects": null,
              "throws": []
            },
            {
              "signature": "getAuthorFeed(ServerRequestInterface $request, ResponseInterface $response): ResponseInterface",
              "purpose": "Get Author Key feed",
              "parameters": [],
              "returns": "`ResponseInterface` with status 200 and JSON body `{\"data\": {\"data\": [posts], \"paging\": {...}}}`",
              "uses": null,
              "endpoint": "GET /api/feed/author",
              "auth": "Author Key JWT (`typ=key`, Primary or Secondary)",
              "required_permission": "posts:read",
              "required_mask": null,
              "request_attributes_used": [
                "key_id (from JwtKeyMiddleware, stored as $authorKeyIdHex32)",
                "permissions (from JwtKeyMiddleware)"
              ],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [
                "limit (int, optional, default: 20, max: 100)",
                "before_id (string, optional, hex32 cursor for older posts)",
                "since_id (string, optional, hex32 cursor for newer posts)"
              ],
              "process": [
                "1. Extract `key_id` and `permissions` from request attributes",
                "2. Validate `key_id` exists",
                "3. Parse query parameters (`limit`, `before_id`, `since_id`)",
                "4. Validate that `before_id` and `since_id` are not both provided",
                "5. Call `FeedService::getAuthorFeed($authorKeyIdHex32, $permissions, $limit, $beforeIdHex32, $sinceIdHex32)`",
                "6. Return 200 OK response with feed data"
              ],
              "exception_handling": [
                "NotFoundException → 404 Not Found (if key not found or not Author Key)",
                "ForbiddenException → 403 Forbidden with required permissions",
                "InvalidArgumentException → 400 Bad Request"
              ],
              "side_effects": null,
              "throws": []
            }
          ]
        },
        "1.4_console_keycontroller": {
          "number": "1.4",
          "name": "Console KeyController",
          "file": "src/Controllers/Console/KeyController.php",
          "purpose": "Handle key management endpoints for Console JSON surface",
          "dependencies": [
            "ResponseFactoryInterface",
            "KeyService",
            "KeyRepository"
          ],
          "methods": [
            {
              "signature": "__construct(ResponseFactoryInterface $responseFactory, KeyService $keyService, KeyRepository $keyRepository)",
              "purpose": "Initialize controller",
              "parameters": [
                {
                  "name": "$responseFactory",
                  "description": "PSR-7 response factory"
                },
                {
                  "name": "$keyService",
                  "description": "Key service instance"
                },
                {
                  "name": "$keyRepository",
                  "description": "Key repository instance"
                }
              ],
              "returns": "void",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [],
              "exception_handling": [],
              "side_effects": "Calls `parent::__construct($responseFactory)`",
              "throws": []
            },
            {
              "signature": "mintPrimary(ServerRequestInterface $request, ResponseInterface $response): ResponseInterface",
              "purpose": "Mint a Primary Author Key",
              "parameters": [],
              "returns": "`ResponseInterface` with status 201 and JSON body `{\"data\": {\"key_id\": \"...\", \"key_public_id\": \"...\", \"key_secret\": \"...\"}}`",
              "uses": null,
              "endpoint": "POST /console/keys/primary",
              "auth": "Owner JWT (`typ=owner`)",
              "required_permission": "keys:issue",
              "required_mask": null,
              "request_attributes_used": [
                "owner_id (from JwtOwnerMiddleware)",
                "permissions (from JwtOwnerMiddleware)"
              ],
              "route_parameters": [],
              "request_body_expected": [
                "permissions (array<string>, required)",
                "label (string, optional)"
              ],
              "query_parameters": [],
              "process": [
                "1. Extract `owner_id` and `permissions` from request attributes",
                "2. Validate `owner_id` exists",
                "3. Parse request body",
                "4. Validate `permissions` is array",
                "5. Validate `label` is string if provided",
                "6. Call `KeyService::mintPrimaryKey($ownerIdHex32, $keyPermissions, $label)`",
                "7. Return 201 Created response with key data (includes `key_secret` - returned only once)"
              ],
              "exception_handling": [
                "ForbiddenException → 403 Forbidden with required permissions",
                "InvalidArgumentException → 400 Bad Request"
              ],
              "side_effects": null,
              "throws": []
            },
            {
              "signature": "list(ServerRequestInterface $request, ResponseInterface $response): ResponseInterface",
              "purpose": "List Owner's keys",
              "parameters": [],
              "returns": "`ResponseInterface` with status 200 and JSON body `{\"data\": [key objects]}`",
              "uses": null,
              "endpoint": "GET /console/keys",
              "auth": "Owner JWT (`typ=owner`)",
              "required_permission": "keys:read",
              "required_mask": null,
              "request_attributes_used": [
                "owner_id (from JwtOwnerMiddleware)",
                "permissions (from JwtOwnerMiddleware)"
              ],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [
                "1. Extract `owner_id` and `permissions` from request attributes",
                "2. Validate `owner_id` exists",
                "3. Call `KeyService::listKeys($ownerIdHex32, $permissions)` (service enforces `keys:read` permission)",
                "4. Return 200 OK response with list of keys"
              ],
              "exception_handling": [
                "ForbiddenException → 403 Forbidden with required permissions"
              ],
              "side_effects": null,
              "throws": []
            },
            {
              "signature": "get(ServerRequestInterface $request, ResponseInterface $response): ResponseInterface",
              "purpose": "Get key details",
              "parameters": [],
              "returns": "`ResponseInterface` with status 200 and JSON body `{\"data\": {key object}}`",
              "uses": null,
              "endpoint": "GET /console/keys/{keyId}",
              "auth": "Owner JWT (`typ=owner`)",
              "required_permission": "keys:read",
              "required_mask": null,
              "request_attributes_used": [
                "owner_id (from JwtOwnerMiddleware)",
                "permissions (from JwtOwnerMiddleware)"
              ],
              "route_parameters": [
                "keyId (hex32)"
              ],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [
                "1. Extract `owner_id` and `permissions` from request attributes",
                "2. Validate `owner_id` exists",
                "3. Extract `keyId` from route parameters",
                "4. Validate `keyId` exists and is string",
                "5. Call `KeyService::getKey($keyIdHex32, $ownerIdHex32, $permissions)` (service enforces `keys:read` permission and ownership verification)",
                "6. Return 200 OK response with key data"
              ],
              "exception_handling": [
                "NotFoundException → 404 Not Found (if key not found or not owned by owner)",
                "ForbiddenException → 403 Forbidden with required permissions"
              ],
              "side_effects": null,
              "throws": []
            },
            {
              "signature": "getLineage(ServerRequestInterface $request, ResponseInterface $response): ResponseInterface",
              "purpose": "View key lineage tree",
              "parameters": [],
              "returns": "`ResponseInterface` with status 200 and JSON body `{\"data\": {\"lineage\": [key objects]}}`",
              "uses": null,
              "endpoint": "GET /console/keys/{keyId}/lineage",
              "auth": "Owner JWT (`typ=owner`)",
              "required_permission": "keys:read",
              "required_mask": null,
              "request_attributes_used": [
                "owner_id (from JwtOwnerMiddleware)",
                "permissions (from JwtOwnerMiddleware)"
              ],
              "route_parameters": [
                "keyId (hex32)"
              ],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [
                "1. Extract `owner_id` and `permissions` from request attributes",
                "2. Validate `owner_id` exists",
                "3. Verify `keys:read` permission in `$permissions` array",
                "4. Extract `keyId` from route parameters",
                "5. Validate `keyId` exists and is string",
                "6. Load key via `KeyRepository::findById($keyIdHex32)`",
                "7. If key not found, return 404",
                "8. Get lineage tree via `KeyRepository::getLineageTree($keyIdHex32)`",
                "9. Return 200 OK response with lineage data"
              ],
              "exception_handling": [],
              "side_effects": null,
              "throws": []
            },
            {
              "signature": "rotate(ServerRequestInterface $request, ResponseInterface $response): ResponseInterface",
              "purpose": "Rotate a key",
              "parameters": [],
              "returns": "`ResponseInterface` with status 200 and JSON body `{\"data\": {\"old_key_id\": \"...\", \"new_key_id\": \"...\", \"new_key_public_id\": \"...\", \"new_key_secret\": \"...\"}}`",
              "uses": null,
              "endpoint": "POST /console/keys/{keyId}/rotate",
              "auth": "Owner JWT (`typ=owner`)",
              "required_permission": "keys:rotate",
              "required_mask": null,
              "request_attributes_used": [
                "owner_id (from JwtOwnerMiddleware)",
                "permissions (from JwtOwnerMiddleware)"
              ],
              "route_parameters": [
                "keyId (hex32)"
              ],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [
                "1. Extract `owner_id` and `permissions` from request attributes",
                "2. Validate `owner_id` exists",
                "3. Verify `keys:rotate` permission in `$permissions` array",
                "4. Extract `keyId` from route parameters",
                "5. Validate `keyId` exists and is string",
                "6. Call `KeyService::rotateKey($keyIdHex32, $ownerIdHex32, 'owner')`",
                "7. Return 200 OK response with rotation result (includes `new_key_secret` - returned only once)"
              ],
              "exception_handling": [
                "NotFoundException → 404 Not Found",
                "InvalidArgumentException → 400 Bad Request"
              ],
              "side_effects": null,
              "throws": []
            },
            {
              "signature": "activate(ServerRequestInterface $request, ResponseInterface $response): ResponseInterface",
              "purpose": "Activate a key",
              "parameters": [],
              "returns": "`ResponseInterface` with status 200 and JSON body `{\"data\": {\"key_id\": \"...\", \"active\": true}}`",
              "uses": null,
              "endpoint": "POST /console/keys/{keyId}/activate",
              "auth": "Owner JWT (`typ=owner`)",
              "required_permission": "keys:state:update",
              "required_mask": null,
              "request_attributes_used": [
                "owner_id (from JwtOwnerMiddleware)",
                "permissions (from JwtOwnerMiddleware)"
              ],
              "route_parameters": [
                "keyId (hex32)"
              ],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [
                "1. Extract `owner_id` and `permissions` from request attributes",
                "2. Validate `owner_id` exists",
                "3. Verify `keys:state:update` permission in `$permissions` array",
                "4. Extract `keyId` from route parameters",
                "5. Validate `keyId` exists and is string",
                "6. Call `KeyService::activateKey($keyIdHex32, $ownerIdHex32, 'owner')`",
                "7. Load key via `KeyRepository::findById($keyIdHex32)` to verify",
                "8. Return 200 OK response with key status"
              ],
              "exception_handling": [
                "NotFoundException → 404 Not Found"
              ],
              "side_effects": null,
              "throws": []
            },
            {
              "signature": "deactivate(ServerRequestInterface $request, ResponseInterface $response): ResponseInterface",
              "purpose": "Deactivate a key",
              "parameters": [],
              "returns": "`ResponseInterface` with status 200 and JSON body `{\"data\": {\"key_id\": \"...\", \"active\": false, \"keys_deactivated\": N}}`",
              "uses": null,
              "endpoint": "POST /console/keys/{keyId}/deactivate",
              "auth": "Owner JWT (`typ=owner`)",
              "required_permission": "keys:state:update",
              "required_mask": null,
              "request_attributes_used": [
                "owner_id (from JwtOwnerMiddleware)",
                "permissions (from JwtOwnerMiddleware)"
              ],
              "route_parameters": [
                "keyId (hex32)"
              ],
              "request_body_expected": [
                "cascade (bool, optional, default: false)"
              ],
              "query_parameters": [],
              "process": [
                "1. Extract `owner_id` and `permissions` from request attributes",
                "2. Validate `owner_id` exists",
                "3. Verify `keys:state:update` permission in `$permissions` array",
                "4. Extract `keyId` from route parameters",
                "5. Validate `keyId` exists and is string",
                "6. Parse request body for `cascade` option (default: false)",
                "7. Call `KeyService::deactivateKey($keyIdHex32, $cascade, $ownerIdHex32, 'owner')`",
                "8. Return 200 OK response with deactivation result"
              ],
              "exception_handling": [
                "NotFoundException → 404 Not Found"
              ],
              "side_effects": null,
              "throws": []
            }
          ]
        },
        "1.18_healthcontroller": {
          "number": "1.18",
          "name": "HealthController",
          "file": "src/Controllers/HealthController.php",
          "purpose": "Provides health check endpoint for monitoring and load balancer health checks",
          "dependencies": [
            "ResponseFactoryInterface",
            "ContainerInterface",
            "PDO"
          ],
          "methods": [
            {
              "signature": "__construct(ResponseFactoryInterface $responseFactory, ?ContainerInterface $container = null)",
              "purpose": "Initialize controller with response factory and optional container",
              "parameters": [
                {
                  "name": "$responseFactory",
                  "description": "PSR-7 response factory"
                },
                {
                  "name": "$container",
                  "description": "PSR-11 container (optional, for DB check)"
                }
              ],
              "returns": "void",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [
                "1. Calls parent::__construct($responseFactory)"
              ],
              "exception_handling": [],
              "side_effects": "Stores container reference",
              "throws": []
            },
            {
              "signature": "health(ServerRequestInterface $request, ResponseInterface $response): ResponseInterface",
              "purpose": "Health check endpoint",
              "parameters": [],
              "returns": "ResponseInterface with status 200 (ok) or 503 (degraded) and JSON body",
              "uses": null,
              "endpoint": "GET /health",
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [
                "1. Initialize data array with status='ok' and timestamp",
                "2. If container available, check database connectivity",
                "3. Set database status to 'ok' or 'error'",
                "4. If database error, set overall status to 'degraded'",
                "5. Return response with appropriate status code"
              ],
              "exception_handling": [
                "Catches Throwable for DB check, sets degraded status"
              ],
              "side_effects": null,
              "throws": []
            }
          ]
        },
        "1.19_jwkscontroller": {
          "number": "1.19",
          "name": "JwksController",
          "file": "src/Controllers/JwksController.php",
          "purpose": "Publishes RS256 public keys for JWT verification via JWKS endpoint",
          "dependencies": [
            "ResponseFactoryInterface",
            "JwtService"
          ],
          "methods": [
            {
              "signature": "__construct(ResponseFactoryInterface $responseFactory, JwtService $jwtService)",
              "purpose": "Initialize controller",
              "parameters": [
                {
                  "name": "$responseFactory",
                  "description": "PSR-7 response factory"
                },
                {
                  "name": "$jwtService",
                  "description": "JWT service for key ID"
                }
              ],
              "returns": "void",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [
                "1. Calls parent::__construct($responseFactory)",
                "2. Stores JwtService reference"
              ],
              "exception_handling": [],
              "side_effects": null,
              "throws": []
            },
            {
              "signature": "jwks(ServerRequestInterface $request, ResponseInterface $response): ResponseInterface",
              "purpose": "Get JWKS (JSON Web Key Set)",
              "parameters": [],
              "returns": "ResponseInterface with JSON body containing keys array",
              "uses": null,
              "endpoint": "GET /.well-known/jwks.json",
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [
                "1. Read public key from JWT_PUBLIC_KEY_PATH",
                "2. Extract RSA modulus and exponent",
                "3. Base64url encode modulus (n) and exponent (e)",
                "4. Get key ID from JwtService",
                "5. Build JWKS response with current key",
                "6. Check for old key during rotation overlap period",
                "7. Add old key to set if present",
                "8. Return JWKS with Cache-Control headers"
              ],
              "exception_handling": [
                "RuntimeException → Returns empty keys array with 500 status",
                "All exceptions caught and return empty keys array"
              ],
              "side_effects": null,
              "throws": []
            }
          ]
        },
        "1.20_ownercontroller": {
          "number": "1.20",
          "name": "OwnerController",
          "file": "src/Controllers/OwnerController.php",
          "purpose": "Handles Owner registration and login endpoints",
          "dependencies": [
            "ResponseFactoryInterface",
            "AuthService"
          ],
          "methods": [
            {
              "signature": "__construct(ResponseFactoryInterface $responseFactory, AuthService $authService)",
              "purpose": "Initialize controller",
              "parameters": [
                {
                  "name": "$responseFactory",
                  "description": "PSR-7 response factory"
                },
                {
                  "name": "$authService",
                  "description": "Authentication service"
                }
              ],
              "returns": "void",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [
                "1. Calls parent::__construct($responseFactory)",
                "2. Stores AuthService reference"
              ],
              "exception_handling": [],
              "side_effects": null,
              "throws": []
            },
            {
              "signature": "register(ServerRequestInterface $request, ResponseInterface $response): ResponseInterface",
              "purpose": "Register a new owner",
              "parameters": [],
              "returns": "ResponseInterface with status 201 and owner_id",
              "uses": null,
              "endpoint": "POST /console/owners",
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [
                "email (string, required)",
                "password (string, required)"
              ],
              "query_parameters": [],
              "process": [
                "1. Parse request body",
                "2. Validate email and password are present",
                "3. Call AuthService::registerOwner($email, $password)",
                "4. Return 201 Created with owner_id"
              ],
              "exception_handling": [
                "InvalidArgumentException → 422 Validation Failed",
                "Security: Generic error messages to prevent oracle leakage"
              ],
              "side_effects": null,
              "throws": []
            },
            {
              "signature": "login(ServerRequestInterface $request, ResponseInterface $response): ResponseInterface",
              "purpose": "Login owner",
              "parameters": [],
              "returns": "ResponseInterface with status 200 and tokens",
              "uses": null,
              "endpoint": "POST /console/login",
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [
                "email (string, required)",
                "password (string, required)"
              ],
              "query_parameters": [],
              "process": [
                "1. Parse request body",
                "2. Validate email and password",
                "3. Extract client IP from REMOTE_ADDR or X-Forwarded-For",
                "4. Extract User-Agent header",
                "5. Call AuthService::loginOwner($email, $password, $ip, $userAgent)",
                "6. Return tokens"
              ],
              "exception_handling": [
                "InvalidArgumentException → 401 Unauthorized (generic message)",
                "Security: Always returns generic error"
              ],
              "side_effects": null,
              "throws": []
            },
            {
              "signature": "refresh(ServerRequestInterface $request, ResponseInterface $response): ResponseInterface",
              "purpose": "Refresh access token",
              "parameters": [],
              "returns": "ResponseInterface with status 200 and new tokens",
              "uses": null,
              "endpoint": "POST /api/auth/refresh",
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [
                "refresh_token (string, required)"
              ],
              "query_parameters": [],
              "process": [
                "1. Parse request body",
                "2. Validate refresh_token present",
                "3. Extract client IP and User-Agent",
                "4. Call AuthService::refreshToken($refreshToken, $ip, $userAgent)",
                "5. Return new tokens"
              ],
              "exception_handling": [
                "InvalidArgumentException → 401 Unauthorized (generic message)"
              ],
              "side_effects": null,
              "throws": []
            },
            {
              "signature": "exchange(ServerRequestInterface $request, ResponseInterface $response): ResponseInterface",
              "purpose": "Exchange ApiKey for JWT tokens",
              "parameters": [],
              "returns": "ResponseInterface with status 200 and tokens",
              "uses": null,
              "endpoint": "POST /api/auth/exchange",
              "auth": "ApiKey (Authorization: ApiKey <public_id>:<secret>)",
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [
                "1. Parse Authorization header",
                "2. Extract ApiKey credentials (public_id:secret)",
                "3. Extract client IP and User-Agent",
                "4. Call AuthService::exchangeApiKey($keyPublicId, $keySecret, $ip, $userAgent)",
                "5. Return tokens"
              ],
              "exception_handling": [
                "InvalidArgumentException → 401 Unauthorized (generic message)"
              ],
              "side_effects": null,
              "throws": []
            }
          ]
        }
      }
    },
    "2_services": {
      "number": "2",
      "name": "Services",
      "components": {
        "2.1_baseservice": {
          "number": "2.1",
          "name": "BaseService",
          "file": "src/Services/BaseService.php",
          "purpose": "Enforces architectural boundaries - services contain business logic, authorization checks, transactions. Services MUST NOT access HTTP concerns or write direct SQL queries.",
          "dependencies": [],
          "methods": []
        },
        "2.2_postservice": {
          "number": "2.2",
          "name": "PostService",
          "file": "src/Services/PostService.php",
          "purpose": "Handles post creation and access management with authorization checks",
          "dependencies": [
            "PostRepository",
            "PostAccessRepository",
            "KeyRepository",
            "GroupRepository",
            "GroupMemberRepository",
            "AuditService",
            "PermissionCatalog",
            "PostAccessBitmask",
            "Ids"
          ],
          "methods": [
            {
              "signature": "__construct(PostRepository $postRepo, PostAccessRepository $postAccessRepo, KeyRepository $keyRepo, GroupRepository $groupRepo, GroupMemberRepository $groupMemberRepo, AuditService $auditService)",
              "purpose": "Initialize service with repositories",
              "parameters": [],
              "returns": "void",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [],
              "exception_handling": [],
              "side_effects": "None",
              "throws": []
            },
            {
              "signature": "createPost(string $authorKeyIdHex32, string $content, ?string $title = null): array",
              "purpose": "Create a new post",
              "parameters": [
                {
                  "name": "$authorKeyIdHex32",
                  "description": "Author key ID from JWT (hex32)"
                },
                {
                  "name": "$content",
                  "description": "Post content (1-10000 chars)"
                },
                {
                  "name": "$title",
                  "description": "Post title (optional, 1-255 chars)"
                }
              ],
              "returns": "`array{post_id: string, author_key_id: string, initial_author_key_id: string, content: string, title: string|null, created_at: string}`",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [
                "1. Validate content length (1-10000 chars using `mb_strlen()`)",
                "2. Validate title length if provided (1-255 chars)",
                "3. Load author key via `KeyRepository::findById($authorKeyIdHex32)`",
                "4. Verify key exists (throw ForbiddenException if not)",
                "5. Verify key is active (`active = true`)",
                "6. Verify key has `posts:create` permission in `permissions` array",
                "7. Verify key type is `primary` or `secondary` (NOT `use`)",
                "8. Get `initial_author_key_id` from key (for provenance)",
                "9. Generate post ID via `Ids::generateHex32Id()`",
                "10. Create post via `PostRepository::create([...])`",
                "11. Load created post via `PostRepository::findById($postIdHex32)`",
                "12. Emit audit event via `AuditService::emit()` (actor: key, action: 'posts:create', subject: post)",
                "13. Return post data array"
              ],
              "exception_handling": [],
              "side_effects": null,
              "throws": [
                "ForbiddenException if key lacks permission or is Use Key",
                "InvalidArgumentException if validation fails",
                "RuntimeException if post creation fails"
              ]
            },
            {
              "signature": "grantAccess(string $postIdHex32, string $requesterKeyIdHex32, array $requesterPermissions, string $targetType, string $targetIdHex32, int $permissionMask): array",
              "purpose": "Grant access to a post (key or group)",
              "parameters": [
                {
                  "name": "$postIdHex32",
                  "description": "Post ID (hex32)"
                },
                {
                  "name": "$requesterKeyIdHex32",
                  "description": "Requester key ID from JWT (hex32)"
                },
                {
                  "name": "$requesterPermissions",
                  "description": "Requester permissions from JWT"
                },
                {
                  "name": "$targetType",
                  "description": "Target type ('key' or 'group')"
                },
                {
                  "name": "$targetIdHex32",
                  "description": "Target ID (hex32)"
                },
                {
                  "name": "$permissionMask",
                  "description": "Permission mask (must be valid)"
                }
              ],
              "returns": "`array{access_id: string, post_id: string, target_type: string, target_id: string, permission_mask: int}`",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [
                "1. Validate `target_type` is 'key' or 'group'",
                "2. Validate permission mask via `PostAccessBitmask::isValid($permissionMask)`",
                "3. Reject zero mask (must grant at least one permission)",
                "4. Verify post exists via `PostRepository::findById($postIdHex32)`",
                "5. Verify requester has `posts:access:manage` permission",
                "6. Get requester's groups via `GroupMemberRepository::findGroupsForKey($requesterKeyIdHex32)`",
                "7. Resolve requester's access mask via `PostAccessRepository::resolveAccessMask($postIdHex32, $requesterKeyIdHex32, $requesterGroups)`",
                "8. Verify requester has MANAGE_ACCESS mask via `PostAccessBitmask::hasManageAccess($requesterMask)`",
                "9. Verify target exists (key via `KeyRepository::findById()` or group via `GroupRepository::findById()`)",
                "10. Generate access ID via `Ids::generateHex32Id()`",
                "11. Upsert access grant via `PostAccessRepository::upsert([...])`",
                "12. Emit audit event via `AuditService::emit()` (actor: key, action: 'posts:access:grant', subject: post)",
                "13. Return access grant data array"
              ],
              "exception_handling": [],
              "side_effects": null,
              "throws": [
                "NotFoundException if post or target not found",
                "ForbiddenException if requester lacks permission or MANAGE_ACCESS mask",
                "InvalidArgumentException if validation fails"
              ]
            },
            {
              "signature": "revokeAccess(string $postIdHex32, string $requesterKeyIdHex32, array $requesterPermissions, string $targetType, string $targetIdHex32): void",
              "purpose": "Revoke access to a post",
              "parameters": [
                {
                  "name": "$postIdHex32",
                  "description": "Post ID (hex32)"
                },
                {
                  "name": "$requesterKeyIdHex32",
                  "description": "Requester key ID from JWT (hex32)"
                },
                {
                  "name": "$requesterPermissions",
                  "description": "Requester permissions from JWT"
                },
                {
                  "name": "$targetType",
                  "description": "Target type ('key' or 'group')"
                },
                {
                  "name": "$targetIdHex32",
                  "description": "Target ID (hex32)"
                }
              ],
              "returns": "void",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [
                "1. Validate `target_type` is 'key' or 'group'",
                "2. Verify post exists via `PostRepository::findById($postIdHex32)`",
                "3. Verify requester has `posts:access:manage` permission",
                "4. Get requester's groups via `GroupMemberRepository::findGroupsForKey($requesterKeyIdHex32)`",
                "5. Resolve requester's access mask via `PostAccessRepository::resolveAccessMask($postIdHex32, $requesterKeyIdHex32, $requesterGroups)`",
                "6. Verify requester has MANAGE_ACCESS mask via `PostAccessBitmask::hasManageAccess($requesterMask)`",
                "7. Revoke access grant via `PostAccessRepository::revoke($postIdHex32, $targetType, $targetIdHex32)`",
                "8. Emit audit event via `AuditService::emit()` (actor: key, action: 'posts:access:revoke', subject: post)"
              ],
              "exception_handling": [],
              "side_effects": null,
              "throws": [
                "NotFoundException if post not found",
                "ForbiddenException if requester lacks permission or MANAGE_ACCESS mask",
                "InvalidArgumentException if validation fails"
              ]
            },
            {
              "signature": "listPosts(string $keyIdHex32, array $keyPermissions, int $limit = 20, ?string $beforeIdHex32 = null): array",
              "purpose": "List posts accessible to a key (Gateway)",
              "parameters": [
                {
                  "name": "$keyIdHex32",
                  "description": "Key ID from JWT (hex32)"
                },
                {
                  "name": "$keyPermissions",
                  "description": "Key permissions from JWT"
                },
                {
                  "name": "$limit",
                  "description": "Limit (default: 20, max: 100)"
                },
                {
                  "name": "$beforeIdHex32",
                  "description": "Cursor for pagination (post ID before this)"
                }
              ],
              "returns": "`array<array>` List of posts",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [
                "1. Verify key has `posts:read` permission",
                "2. Get groups the key belongs to via `GroupMemberRepository::findGroupsForKey($keyIdHex32)`",
                "3. Find visible posts via `PostRepository::findVisiblePostsForUseKey($keyIdHex32, $groupIdsHex32, $limit, $beforeIdHex32)`",
                "4. Return posts array"
              ],
              "exception_handling": [],
              "side_effects": null,
              "throws": [
                "ForbiddenException if key lacks permission"
              ]
            },
            {
              "signature": "getPost(string $postIdHex32, string $keyIdHex32, array $keyPermissions): array",
              "purpose": "Get post details (Gateway)",
              "parameters": [
                {
                  "name": "$postIdHex32",
                  "description": "Post ID (hex32)"
                },
                {
                  "name": "$keyIdHex32",
                  "description": "Key ID from JWT (hex32)"
                },
                {
                  "name": "$keyPermissions",
                  "description": "Key permissions from JWT"
                }
              ],
              "returns": "`array` Post data",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [
                "1. Verify key has `posts:read` permission",
                "2. Load post via `PostRepository::findById($postIdHex32)`",
                "3. If post not found, throw NotFoundException",
                "4. Get key's groups via `GroupMemberRepository::findGroupsForKey($keyIdHex32)`",
                "5. Resolve access mask via `PostAccessRepository::resolveAccessMask($postIdHex32, $keyIdHex32, $groupIdsHex32)`",
                "6. Verify key has VIEW mask via `PostAccessBitmask::hasView($accessMask)`",
                "7. If no VIEW mask, throw NotFoundException (hide existence)",
                "8. Return post data array"
              ],
              "exception_handling": [],
              "side_effects": null,
              "throws": [
                "NotFoundException if post not found or key lacks access",
                "ForbiddenException if key lacks permission"
              ]
            },
            {
              "signature": "listPostsByOwner(string $ownerIdHex32, array $ownerPermissions, int $limit = 20, ?string $beforeIdHex32 = null): array",
              "purpose": "List posts owned by an owner",
              "parameters": [
                {
                  "name": "$ownerIdHex32",
                  "description": "Owner ID from JWT (hex32)"
                },
                {
                  "name": "$ownerPermissions",
                  "description": "Owner permissions from JWT"
                },
                {
                  "name": "$limit",
                  "description": "Limit (default: 20)"
                },
                {
                  "name": "$beforeIdHex32",
                  "description": "Cursor for pagination (post ID before this)"
                }
              ],
              "returns": "`array{posts: array, paging: array{limit: int, before_id: string|null, next_cursor: string|null}}`",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [
                "1. Verify owner has `posts:admin:read` permission",
                "2. Find owner's primary keys via `KeyRepository::findByOwner($ownerIdHex32)`",
                "3. Extract primary key IDs array",
                "4. Find posts by owner via `PostRepository::findByOwner($primaryKeyIds, $limit, $beforeIdHex32)`",
                "5. Determine next cursor (last post ID if there are results)",
                "6. Return posts with paging info"
              ],
              "exception_handling": [],
              "side_effects": null,
              "throws": [
                "ForbiddenException if owner lacks permission"
              ]
            },
            {
              "signature": "getPostForOwner(string $postIdHex32, string $ownerIdHex32, array $ownerPermissions): array",
              "purpose": "Get post details for owner admin view",
              "parameters": [
                {
                  "name": "$postIdHex32",
                  "description": "Post ID (hex32)"
                },
                {
                  "name": "$ownerIdHex32",
                  "description": "Owner ID from JWT (hex32)"
                },
                {
                  "name": "$ownerPermissions",
                  "description": "Owner permissions from JWT"
                }
              ],
              "returns": "`array` Post data",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [
                "1. Verify owner has `posts:admin:read` permission",
                "2. Load post via `PostRepository::findById($postIdHex32)`",
                "3. If post not found, throw NotFoundException",
                "4. Find owner's primary keys via `KeyRepository::findByOwner($ownerIdHex32)`",
                "5. Extract primary key IDs array",
                "6. Verify post's `initial_author_key_id` matches one of owner's primary keys",
                "7. If not owned, throw NotFoundException (hide existence)",
                "8. Return post data array"
              ],
              "exception_handling": [],
              "side_effects": null,
              "throws": [
                "NotFoundException if post not found or not owned by owner",
                "ForbiddenException if owner lacks permission"
              ]
            },
            {
              "signature": "grantGroupAccess(string $postIdHex32, string $ownerIdHex32, array $ownerPermissions, string $groupIdHex32, int $permissionMask): array",
              "purpose": "Grant group access to a post (Console variant)",
              "parameters": [
                {
                  "name": "$postIdHex32",
                  "description": "Post ID (hex32)"
                },
                {
                  "name": "$ownerIdHex32",
                  "description": "Owner ID from JWT (hex32)"
                },
                {
                  "name": "$ownerPermissions",
                  "description": "Owner permissions from JWT"
                },
                {
                  "name": "$groupIdHex32",
                  "description": "Group ID (hex32)"
                },
                {
                  "name": "$permissionMask",
                  "description": "Permission mask (must be valid)"
                }
              ],
              "returns": "`array{access_id: string, post_id: string, group_id: string, permission_mask: int}`",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [
                "1. Validate permission mask via `PostAccessBitmask::isValid($permissionMask)`",
                "2. Reject zero mask",
                "3. Verify owner has `posts:access:manage` permission",
                "4. Load post and verify ownership (via initial_author_key_id matching owner's primary keys)",
                "5. Verify group exists and is owned by owner",
                "6. Generate access ID via `Ids::generateHex32Id()`",
                "7. Upsert access grant via `PostAccessRepository::upsert([...])`",
                "8. Emit audit event via `AuditService::emit()` (actor: owner, action: 'posts:access:grant-group', subject: post)",
                "9. Return access grant data array"
              ],
              "exception_handling": [],
              "side_effects": null,
              "throws": [
                "NotFoundException if post or group not found or not owned by owner",
                "ForbiddenException if owner lacks permission",
                "InvalidArgumentException if validation fails"
              ]
            },
            {
              "signature": "revokeGroupAccess(string $postIdHex32, string $ownerIdHex32, array $ownerPermissions, string $groupIdHex32): void",
              "purpose": "Revoke group access to a post (Console variant)",
              "parameters": [
                {
                  "name": "$postIdHex32",
                  "description": "Post ID (hex32)"
                },
                {
                  "name": "$ownerIdHex32",
                  "description": "Owner ID from JWT (hex32)"
                },
                {
                  "name": "$ownerPermissions",
                  "description": "Owner permissions from JWT"
                },
                {
                  "name": "$groupIdHex32",
                  "description": "Group ID (hex32)"
                }
              ],
              "returns": "void",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [
                "1. Verify owner has `posts:access:manage` permission",
                "2. Load post and verify ownership (via initial_author_key_id matching owner's primary keys)",
                "3. Verify group exists and is owned by owner",
                "4. Revoke access grant via `PostAccessRepository::revoke($postIdHex32, 'group', $groupIdHex32)`",
                "5. Emit audit event via `AuditService::emit()` (actor: owner, action: 'posts:access:revoke', subject: post)"
              ],
              "exception_handling": [],
              "side_effects": null,
              "throws": [
                "NotFoundException if post or group not found or not owned by owner",
                "ForbiddenException if owner lacks permission"
              ]
            }
          ]
        },
        "2.3_commentservice": {
          "number": "2.3",
          "name": "CommentService",
          "file": "src/Services/CommentService.php",
          "purpose": "Handles comment creation and listing with authorization checks",
          "dependencies": [
            "CommentRepository",
            "PostRepository",
            "PostAccessRepository",
            "GroupMemberRepository",
            "AuditService",
            "PostAccessBitmask",
            "Ids"
          ],
          "methods": [
            {
              "signature": "__construct(CommentRepository $commentRepo, PostRepository $postRepo, PostAccessRepository $postAccessRepo, GroupMemberRepository $groupMemberRepo, AuditService $auditService)",
              "purpose": "Initialize service with repositories",
              "parameters": [],
              "returns": "void",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [],
              "exception_handling": [],
              "side_effects": "None",
              "throws": []
            },
            {
              "signature": "createComment(string $postIdHex32, string $authorKeyIdHex32, array $authorPermissions, string $body): array",
              "purpose": "Create a new comment",
              "parameters": [
                {
                  "name": "$postIdHex32",
                  "description": "Post ID (hex32)"
                },
                {
                  "name": "$authorKeyIdHex32",
                  "description": "Author key ID from JWT (hex32)"
                },
                {
                  "name": "$authorPermissions",
                  "description": "Author permissions from JWT"
                },
                {
                  "name": "$body",
                  "description": "Comment body (1-5000 chars)"
                }
              ],
              "returns": "`array{comment_id: string, post_id: string, created_by_key_id: string, body: string, created_at: string}`",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [
                "1. Validate body length (1-5000 chars using `mb_strlen()`)",
                "2. Verify post exists via `PostRepository::findById($postIdHex32)`",
                "3. Verify key has `comments:write` permission",
                "4. Get key's groups via `GroupMemberRepository::findGroupsForKey($authorKeyIdHex32)`",
                "5. Resolve access mask via `PostAccessRepository::resolveAccessMask($postIdHex32, $authorKeyIdHex32, $keyGroups)`",
                "6. Check if key has VIEW access (to verify post is visible)",
                "7. If no VIEW mask, throw NotFoundException (hide existence)",
                "8. Check if key has COMMENT mask via `PostAccessBitmask::hasComment($accessMask)`",
                "9. If no COMMENT mask, throw ForbiddenException",
                "10. Generate comment ID via `Ids::generateHex32Id()`",
                "11. Create comment via `CommentRepository::create([...])`",
                "12. Load created comment via `CommentRepository::findById($commentIdHex32)`",
                "13. Emit audit event via `AuditService::emit()` (actor: key, action: 'comments:create', subject: comment)",
                "14. Return comment data array"
              ],
              "exception_handling": [],
              "side_effects": null,
              "throws": [
                "NotFoundException if post not found or not visible",
                "ForbiddenException if key lacks permission or COMMENT mask",
                "InvalidArgumentException if validation fails"
              ]
            },
            {
              "signature": "listComments(string $postIdHex32, string $viewerKeyIdHex32, array $viewerPermissions, int $limit = 20, ?string $beforeIdHex32 = null): array",
              "purpose": "List comments for a post",
              "parameters": [
                {
                  "name": "$postIdHex32",
                  "description": "Post ID (hex32)"
                },
                {
                  "name": "$viewerKeyIdHex32",
                  "description": "Viewer key ID from JWT (hex32)"
                },
                {
                  "name": "$viewerPermissions",
                  "description": "Viewer permissions from JWT"
                },
                {
                  "name": "$limit",
                  "description": "Limit (default: 20, max: 100)"
                },
                {
                  "name": "$beforeIdHex32",
                  "description": "Cursor for pagination (comment ID before this)"
                }
              ],
              "returns": "`array{comments: array, paging: array{limit: int, before_id: string|null, next_cursor: string|null}}`",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [
                "1. Validate limit (1-100)",
                "2. Verify post exists via `PostRepository::findById($postIdHex32)`",
                "3. Verify key has `posts:read` permission",
                "4. Get key's groups via `GroupMemberRepository::findGroupsForKey($viewerKeyIdHex32)`",
                "5. Resolve access mask via `PostAccessRepository::resolveAccessMask($postIdHex32, $viewerKeyIdHex32, $keyGroups)`",
                "6. Check if key has VIEW access",
                "7. If no VIEW mask, throw NotFoundException (hide existence)",
                "8. Find comments via `CommentRepository::findByPost($postIdHex32, $limit, $beforeIdHex32)`",
                "9. Determine next cursor (last comment ID if there are results)",
                "10. Return comments with paging info"
              ],
              "exception_handling": [],
              "side_effects": null,
              "throws": [
                "NotFoundException if post not found or not visible",
                "ForbiddenException if key lacks permission or VIEW mask",
                "InvalidArgumentException if limit validation fails"
              ]
            }
          ]
        },
        "2.4_feedservice": {
          "number": "2.4",
          "name": "FeedService",
          "file": "src/Services/FeedService.php",
          "purpose": "Handles feed operations for Gateway JSON surface",
          "dependencies": [
            "PostRepository",
            "GroupMemberRepository",
            "KeyRepository"
          ],
          "methods": [
            {
              "signature": "__construct(PostRepository $postRepo, GroupMemberRepository $groupMemberRepo, KeyRepository $keyRepo)",
              "purpose": "Initialize service with repositories",
              "parameters": [],
              "returns": "void",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [],
              "exception_handling": [],
              "side_effects": "None",
              "throws": []
            },
            {
              "signature": "getUseKeyFeed(string $useKeyIdHex32, string $jwtKeyIdHex32, array $keyPermissions, int $limit = 20, ?string $beforeIdHex32 = null, ?string $sinceIdHex32 = null): array",
              "purpose": "Get Use Key feed",
              "parameters": [
                {
                  "name": "$useKeyIdHex32",
                  "description": "Use Key ID from path (hex32)"
                },
                {
                  "name": "$jwtKeyIdHex32",
                  "description": "Key ID from JWT (hex32) - must match useKeyIdHex32"
                },
                {
                  "name": "$keyPermissions",
                  "description": "Key permissions from JWT"
                },
                {
                  "name": "$limit",
                  "description": "Limit (default 20, max 100)"
                },
                {
                  "name": "$beforeIdHex32",
                  "description": "Cursor for older posts (post ID)"
                },
                {
                  "name": "$sinceIdHex32",
                  "description": "Cursor for newer posts (post ID)"
                }
              ],
              "returns": "`array{data: array<array>, paging: array{limit: int, cursor: string|null}}`",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [
                "1. Validate limit (1-100)",
                "2. **Path Guard:** Validate that path key ID matches JWT key ID (throw NotFoundException if mismatch - hides existence)",
                "3. Verify key has `posts:read` permission",
                "4. Verify key exists via `KeyRepository::findById($useKeyIdHex32)`",
                "5. Get groups the key belongs to via `GroupMemberRepository::findGroupsForKey($useKeyIdHex32)`",
                "6. Find visible posts via `PostRepository::findVisiblePostsForUseKey($useKeyIdHex32, $groupIdsHex32, $limit, $beforeIdHex32, $sinceIdHex32)`",
                "7. Determine cursor (last post ID in result set, or null if empty)",
                "8. Return feed data with paging info"
              ],
              "exception_handling": [],
              "side_effects": null,
              "throws": [
                "NotFoundException if key not found or path/JWT mismatch (path guard)",
                "ForbiddenException if key lacks permission",
                "InvalidArgumentException if validation fails"
              ]
            },
            {
              "signature": "getAuthorFeed(string $authorKeyIdHex32, array $keyPermissions, int $limit = 20, ?string $beforeIdHex32 = null, ?string $sinceIdHex32 = null): array",
              "purpose": "Get Author Key feed",
              "parameters": [
                {
                  "name": "$authorKeyIdHex32",
                  "description": "Author Key ID from JWT (hex32)"
                },
                {
                  "name": "$keyPermissions",
                  "description": "Key permissions from JWT"
                },
                {
                  "name": "$limit",
                  "description": "Limit (default 20, max 100)"
                },
                {
                  "name": "$beforeIdHex32",
                  "description": "Cursor for older posts (post ID)"
                },
                {
                  "name": "$sinceIdHex32",
                  "description": "Cursor for newer posts (post ID)"
                }
              ],
              "returns": "`array{data: array<array>, paging: array{limit: int, cursor: string|null}}`",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [
                "1. Validate limit (1-100)",
                "2. Verify key has `posts:read` permission",
                "3. Verify key exists and is an Author Key (not Use Key) via `KeyRepository::findById($authorKeyIdHex32)`",
                "4. Get groups the key belongs to via `GroupMemberRepository::findGroupsForKey($authorKeyIdHex32)`",
                "5. Get `initial_author_key_id` from key",
                "6. Find posts authored by keys with same initial_author_key_id via `PostRepository::findByInitialAuthor($initialAuthorKeyIdHex32, $limit * 2, $beforeIdHex32, $sinceIdHex32)`",
                "7. Find posts visible via group memberships (if key belongs to groups) via `PostRepository::findVisiblePostsForGroups($groupIdsHex32, $limit * 2, $beforeIdHex32, $sinceIdHex32)`",
                "8. Merge and deduplicate posts (by post_id)",
                "9. Sort by created_at DESC and limit",
                "10. Determine cursor (last post ID in result set, or null if empty)",
                "11. Return feed data with paging info"
              ],
              "exception_handling": [],
              "side_effects": null,
              "throws": [
                "NotFoundException if key not found or not an Author Key",
                "ForbiddenException if key lacks permission",
                "InvalidArgumentException if validation fails"
              ]
            }
          ]
        },
        "2.5_authservice": {
          "number": "2.5",
          "name": "AuthService",
          "file": "src/Services/AuthService.php",
          "purpose": "Handles Owner authentication, password hashing, and token generation",
          "dependencies": [
            "OwnerRepository",
            "RefreshTokenRepository",
            "KeyRepository",
            "KeyPublicIdRepository",
            "KeyDeviceRepository",
            "JwtService",
            "AuditService",
            "Ids"
          ],
          "methods": [
            {
              "signature": "__construct(OwnerRepository $ownerRepository, RefreshTokenRepository $refreshTokenRepository, KeyRepository $keyRepository, KeyPublicIdRepository $keyPublicIdRepository, KeyDeviceRepository $keyDeviceRepository, JwtService $jwtService, AuditService $auditService)",
              "purpose": "Initialize service with repositories and JWT service",
              "parameters": [],
              "returns": "void",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [],
              "exception_handling": [],
              "side_effects": "None",
              "throws": []
            },
            {
              "signature": "registerOwner(string $email, string $password): string",
              "purpose": "Register a new owner",
              "parameters": [
                {
                  "name": "$email",
                  "description": "Owner email"
                },
                {
                  "name": "$password",
                  "description": "Plaintext password"
                }
              ],
              "returns": "`string` Owner ID (hex32)",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [
                "1. Validate email format via `filter_var($email, FILTER_VALIDATE_EMAIL)`",
                "2. Validate password strength (min 8 characters)",
                "3. Check uniqueness via `OwnerRepository::findByEmail($email)`",
                "4. If email exists, throw InvalidArgumentException (generic message - don't reveal existence)",
                "5. Hash password with Argon2id via `hashPassword($password)`",
                "6. Generate owner ID via `Ids::generateHex32Id()`",
                "7. Insert owner via `OwnerRepository::create($ownerIdHex32, $email, $passwordHash)`",
                "8. Emit audit event via `AuditService::emit()` (actor: owner, action: 'owners:register', subject: owner)",
                "9. Return owner ID (hex32)"
              ],
              "exception_handling": [],
              "side_effects": null,
              "throws": [
                "InvalidArgumentException if email already exists or validation fails"
              ]
            },
            {
              "signature": "loginOwner(string $email, string $password, ?string $ip = null, ?string $userAgent = null): array",
              "purpose": "Login owner and generate tokens",
              "parameters": [
                {
                  "name": "$email",
                  "description": "Owner email"
                },
                {
                  "name": "$password",
                  "description": "Plaintext password"
                },
                {
                  "name": "$ip",
                  "description": "Client IP address (optional)"
                },
                {
                  "name": "$userAgent",
                  "description": "User agent string (optional)"
                }
              ],
              "returns": "`array{access_token: string, refresh_token: string, expires_in: int}`",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [
                "1. Lookup owner by email via `OwnerRepository::findByEmail($email)`",
                "2. If owner not found, throw InvalidArgumentException (generic message - don't reveal existence)",
                "3. Verify password via `verifyPassword($password, $owner['password_hash'])`",
                "4. If password invalid, throw InvalidArgumentException (generic message)",
                "5. Generate Owner JWT via `JwtService::signOwnerToken()` with owner permissions and /console audience",
                "6. Generate refresh token via `generateRefreshToken()`",
                "7. Create lookup hash (SHA-256) and token hash (Argon2id)",
                "8. Store refresh token via `RefreshTokenRepository::create([...])`",
                "9. Emit audit event via `AuditService::emit()` (actor: owner, action: 'owners:login', subject: owner)",
                "10. Return tokens array"
              ],
              "exception_handling": [],
              "side_effects": null,
              "throws": [
                "InvalidArgumentException if credentials are invalid (generic message)"
              ]
            },
            {
              "signature": "refreshToken(string $refreshToken, ?string $ip = null, ?string $userAgent = null): array",
              "purpose": "Refresh access token using refresh token",
              "parameters": [
                {
                  "name": "$refreshToken",
                  "description": "Plaintext refresh token"
                },
                {
                  "name": "$ip",
                  "description": "Client IP address (optional)"
                },
                {
                  "name": "$userAgent",
                  "description": "User agent string (optional)"
                }
              ],
              "returns": "`array{access_token: string, refresh_token: string, expires_in: int}`",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [
                "1. Lookup token by SHA-256 hash via `RefreshTokenRepository::findByLookupHash($lookupHash)`",
                "2. If token not found, throw InvalidArgumentException (generic message)",
                "3. Verify token using password_verify (checks Argon2id hash)",
                "4. Verify expires_at is in the future",
                "5. Verify revoked_at is NULL",
                "6. Verify rotated_at is NULL (single-use enforcement)",
                "7. If rotated_at is not NULL, emit audit event for replay attempt and throw InvalidArgumentException",
                "8. Generate new refresh token ID",
                "9. Generate new access JWT based on subject_type (owner or key)",
                "10. Generate new refresh token",
                "11. Store new refresh token via `RefreshTokenRepository::create([...])`",
                "12. Mark old token as rotated via `RefreshTokenRepository::markRotated($tokenData['token_id'], $newRefreshTokenIdHex32)`",
                "13. Emit audit event via `AuditService::emit()` (actor: subject, action: 'refresh_token:rotate', subject: refresh_token)",
                "14. Return new tokens array"
              ],
              "exception_handling": [],
              "side_effects": null,
              "throws": [
                "InvalidArgumentException if refresh token is invalid, expired, revoked, or already rotated"
              ]
            },
            {
              "signature": "exchangeApiKey(string $keyPublicId, string $keySecret, ?string $ip = null, ?string $userAgent = null): array",
              "purpose": "Generate a secure refresh token",
              "parameters": [
                {
                  "name": "$password",
                  "description": "Plaintext password"
                },
                {
                  "name": "$hash",
                  "description": "Argon2id hash"
                }
              ],
              "returns": "`string` Refresh token (format: `rt_<random>`)",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [
                "1. Generate 48 bytes of random data (384 bits)",
                "2. Format as `rt_` + hex string",
                "3. Return token string"
              ],
              "exception_handling": [],
              "side_effects": null,
              "throws": [
                "InvalidArgumentException if credentials are invalid (generic message)",
                "ForbiddenException if use limit or device limit exceeded"
              ]
            }
          ]
        },
        "2.6_keyservice": {
          "number": "2.6",
          "name": "KeyService",
          "file": "src/Services/KeyService.php",
          "purpose": "Handles key minting operations with permission validation",
          "dependencies": [
            "KeyRepository",
            "KeyPublicIdRepository",
            "AuditService",
            "PermissionCatalog",
            "Ids",
            "SensitiveDataSanitizer"
          ],
          "methods": [
            {
              "signature": "__construct(KeyRepository $keyRepo, KeyPublicIdRepository $keyPublicIdRepo, AuditService $auditService)",
              "purpose": "Initialize service with repositories",
              "parameters": [],
              "returns": "void",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [],
              "exception_handling": [],
              "side_effects": "None",
              "throws": []
            },
            {
              "signature": "mintPrimaryKey(string $ownerIdHex32, array $permissions, ?string $label = null): array",
              "purpose": "Mint a Primary Author Key (Owner → Console)",
              "parameters": [
                {
                  "name": "$ownerIdHex32",
                  "description": "Owner ID (hex32)"
                },
                {
                  "name": "$permissions",
                  "description": "Requested permissions"
                },
                {
                  "name": "$label",
                  "description": "Optional label"
                }
              ],
              "returns": "`array{key_id: string, key_public_id: string, key_secret: string}`",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [
                "1. Validate permissions format via `PermissionCatalog::isValidFormat()` for each permission",
                "2. Generate key_id via `Ids::generateHex32Id()`",
                "3. Generate key_public_id (apub_...) via `'apub_' . bin2hex(random_bytes(8))`",
                "4. Generate key_secret via `'sec_' . bin2hex(random_bytes(24))`",
                "5. Hash key_secret with Argon2id via `password_hash($keySecret, PASSWORD_ARGON2ID)`",
                "6. Prepare key data array (includes owner_id for primary keys)",
                "7. **Transaction:**"
              ],
              "exception_handling": [],
              "side_effects": null,
              "throws": [
                "InvalidArgumentException if validation fails"
              ]
            },
            {
              "signature": "mintSecondaryKey(string $parentKeyIdHex32, array $permissions, ?string $label = null): array",
              "purpose": "Mint a Secondary Author Key (Author Key → Gateway)",
              "parameters": [
                {
                  "name": "$parentKeyIdHex32",
                  "description": "Parent key ID (hex32)"
                },
                {
                  "name": "$permissions",
                  "description": "Requested permissions"
                },
                {
                  "name": "$label",
                  "description": "Optional label"
                }
              ],
              "returns": "`array{key_id: string, key_public_id: string, key_secret: string}`",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [
                "1. Load parent key via `KeyRepository::findById($parentKeyIdHex32)`",
                "2. Verify parent key exists (throw NotFoundException if not)",
                "3. Verify parent key is active",
                "4. Verify parent key type (must be primary or secondary)",
                "5. Verify parent has `keys:issue` permission via `validateIssuerCanMint($parentPermissions)`",
                "6. Validate envelope rule via `validatePermissionEnvelope($permissions, $parentPermissions, 'secondary')`",
                "7. Generate new key (key_id, key_public_id, key_secret)",
                "8. Hash key_secret with Argon2id",
                "9. Propagate `initial_author_key_id` from parent",
                "10. Prepare key data array (with lineage fields)",
                "11. **Transaction:**"
              ],
              "exception_handling": [],
              "side_effects": null,
              "throws": [
                "InvalidArgumentException if validation fails",
                "NotFoundException if parent key not found",
                "ForbiddenException if parent cannot mint or envelope violation"
              ]
            },
            {
              "signature": "mintUseKey(string $parentKeyIdHex32, array $permissions, ?int $useCountLimit = null, ?int $deviceLimit = null, ?string $label = null): array",
              "purpose": "Mint a Use Key (Author Key → Gateway)",
              "parameters": [
                {
                  "name": "$parentKeyIdHex32",
                  "description": "Parent key ID (hex32)"
                },
                {
                  "name": "$permissions",
                  "description": "Requested permissions"
                },
                {
                  "name": "$useCountLimit",
                  "description": "Use count limit (optional)"
                },
                {
                  "name": "$deviceLimit",
                  "description": "Device limit (optional)"
                },
                {
                  "name": "$label",
                  "description": "Optional label"
                }
              ],
              "returns": "`array{key_id: string, key_public_id: string, key_secret: string, use_count: int|null, device_limit: int|null}`",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [
                "1. Load parent key via `KeyRepository::findById($parentKeyIdHex32)`",
                "2. Verify parent key exists (throw NotFoundException if not)",
                "3. Verify parent key is active",
                "4. Verify parent key type (must be primary or secondary)",
                "5. Verify parent has `keys:issue` permission via `validateIssuerCanMint($parentPermissions)`",
                "6. Validate envelope rule and Use Key restrictions via `validatePermissionEnvelope($permissions, $parentPermissions, 'use')`",
                "7. Generate new key (key_id, key_public_id, key_secret)",
                "8. Hash key_secret with Argon2id",
                "9. Propagate `initial_author_key_id` from parent",
                "10. Prepare key data array (with lineage fields and limits)",
                "11. **Transaction:**"
              ],
              "exception_handling": [],
              "side_effects": null,
              "throws": [
                "InvalidArgumentException if validation fails",
                "NotFoundException if parent key not found",
                "ForbiddenException if parent cannot mint or envelope violation"
              ]
            },
            {
              "signature": "rotateKey(string $oldKeyIdHex32, ?string $actorTypeHex32 = null, string $actorType = 'owner'): array",
              "purpose": "Rotate a key (replace while preserving lineage)",
              "parameters": [
                {
                  "name": "$oldKeyIdHex32",
                  "description": "Old key ID to rotate (hex32)"
                },
                {
                  "name": "$actorTypeHex32",
                  "description": "Actor ID (hex32) - owner_id if actor_type='owner', key_id if actor_type='key'"
                },
                {
                  "name": "$actorType",
                  "description": "Actor type ('owner' or 'key')"
                }
              ],
              "returns": "`array{old_key_id: string, new_key_id: string, new_key_public_id: string, new_key_secret: string}`",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [
                "1. Load old key via `KeyRepository::findById($oldKeyIdHex32)`",
                "2. Verify key exists (throw NotFoundException if not)",
                "3. Verify key is not already retired (check `retired_at` is NULL)",
                "4. Generate new key with same properties (type, permissions, lineage fields)",
                "5. Generate new key_public_id and key_secret",
                "6. Hash new key_secret with Argon2id",
                "7. Preserve lineage fields from old key",
                "8. Set `rotated_from_id` to old key ID",
                "9. Reset use_count_current to 0 for new key",
                "10. **Transaction:**"
              ],
              "exception_handling": [],
              "side_effects": null,
              "throws": [
                "NotFoundException if old key not found",
                "InvalidArgumentException if key is already retired"
              ]
            },
            {
              "signature": "activateKey(string $keyIdHex32, ?string $actorTypeHex32 = null, string $actorType = 'owner'): void",
              "purpose": "Activate a key",
              "parameters": [
                {
                  "name": "$keyIdHex32",
                  "description": "Key ID (hex32)"
                },
                {
                  "name": "$actorTypeHex32",
                  "description": "Actor ID (hex32) - owner_id if actor_type='owner', key_id if actor_type='key'"
                },
                {
                  "name": "$actorType",
                  "description": "Actor type ('owner' or 'key')"
                }
              ],
              "returns": "void",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [
                "1. Load key via `KeyRepository::findById($keyIdHex32)`",
                "2. Verify key exists (throw NotFoundException if not)",
                "3. Update key active status via `KeyRepository::updateActive($keyIdHex32, true)`",
                "4. Infer actor if not provided (from key's initial_author_key_id)",
                "5. Emit audit event via `AuditService::emit()` (actor: owner/key, action: 'keys:activate', subject: key)"
              ],
              "exception_handling": [],
              "side_effects": null,
              "throws": [
                "NotFoundException if key not found"
              ]
            },
            {
              "signature": "deactivateKey(string $keyIdHex32, bool $cascade = false, ?string $actorTypeHex32 = null, string $actorType = 'owner'): int",
              "purpose": "Validate that issuer has keys:issue permission",
              "parameters": [
                {
                  "name": "$issuerPermissions",
                  "description": "Issuer's permissions"
                }
              ],
              "returns": "void",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [
                "1. Check if `keys:issue` is in `$issuerPermissions` array",
                "2. If not present, throw InvalidArgumentException"
              ],
              "exception_handling": [],
              "side_effects": null,
              "throws": [
                "InvalidArgumentException if issuer lacks keys:issue"
              ]
            },
            {
              "signature": "listKeys(string $ownerIdHex32, array $ownerPermissions): array",
              "purpose": "List keys owned by an owner",
              "parameters": [
                {
                  "name": "$ownerIdHex32",
                  "description": "Owner ID from JWT (hex32)"
                },
                {
                  "name": "$ownerPermissions",
                  "description": "Owner permissions from JWT"
                }
              ],
              "returns": "`array<array>` List of keys",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [
                "1. Verify owner has `keys:read` permission",
                "2. Find all primary keys owned by this owner via `KeyRepository::findByOwner($ownerIdHex32)`",
                "3. For each primary key, find all keys with matching initial_author_key_id via `KeyRepository::findByInitialAuthor($primaryKey['key_id'])`",
                "4. Merge all keys",
                "5. Remove duplicates (by key_id)",
                "6. Return unique keys array"
              ],
              "exception_handling": [],
              "side_effects": null,
              "throws": [
                "ForbiddenException if owner lacks permission"
              ]
            },
            {
              "signature": "getKey(string $keyIdHex32, string $ownerIdHex32, array $ownerPermissions): array",
              "purpose": "Get a key by ID (with ownership verification)",
              "parameters": [
                {
                  "name": "$keyIdHex32",
                  "description": "Key ID (hex32)"
                },
                {
                  "name": "$ownerIdHex32",
                  "description": "Owner ID from JWT (hex32)"
                },
                {
                  "name": "$ownerPermissions",
                  "description": "Owner permissions from JWT"
                }
              ],
              "returns": "`array` Key data",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [
                "1. Verify owner has `keys:read` permission",
                "2. Load key via `KeyRepository::findById($keyIdHex32)`",
                "3. If key not found, throw NotFoundException",
                "4. Verify key belongs to owner:"
              ],
              "exception_handling": [],
              "side_effects": null,
              "throws": [
                "NotFoundException if key not found or not owned by owner",
                "ForbiddenException if owner lacks permission"
              ]
            },
            {
              "signature": "getKeyLineage(string $keyIdHex32, string $ownerIdHex32, array $ownerPermissions): array",
              "purpose": "Get key lineage tree",
              "parameters": [
                {
                  "name": "$keyIdHex32",
                  "description": "Key ID (hex32)"
                },
                {
                  "name": "$ownerIdHex32",
                  "description": "Owner ID from JWT (hex32)"
                },
                {
                  "name": "$ownerPermissions",
                  "description": "Owner permissions from JWT"
                }
              ],
              "returns": "`array<array>` Lineage tree (root to leaf)",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [
                "1. Verify owner has `keys:read` permission",
                "2. Load key via `KeyRepository::findById($keyIdHex32)`",
                "3. If key not found, throw NotFoundException",
                "4. Verify key belongs to owner (same as getKey)",
                "5. Get lineage tree via `KeyRepository::getLineageTree($keyIdHex32)`",
                "6. Return lineage tree array"
              ],
              "exception_handling": [],
              "side_effects": null,
              "throws": [
                "NotFoundException if key not found or not owned by owner",
                "ForbiddenException if owner lacks permission"
              ]
            }
          ]
        },
        "2.7_groupservice": {
          "number": "2.7",
          "name": "GroupService",
          "file": "src/Services/GroupService.php",
          "purpose": "Handles group management operations for Console JSON surface",
          "dependencies": [
            "GroupRepository",
            "GroupMemberRepository",
            "KeyRepository",
            "AuditService",
            "Ids"
          ],
          "methods": [
            {
              "signature": "__construct(GroupRepository $groupRepo, GroupMemberRepository $groupMemberRepo, KeyRepository $keyRepo)",
              "purpose": "Initialize service with repositories",
              "parameters": [],
              "returns": "void",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [],
              "exception_handling": [],
              "side_effects": "None",
              "throws": []
            },
            {
              "signature": "createGroup(string $ownerIdHex32, array $ownerPermissions, string $name): array",
              "purpose": "Create a new group",
              "parameters": [
                {
                  "name": "$ownerIdHex32",
                  "description": "Owner ID from JWT (hex32)"
                },
                {
                  "name": "$ownerPermissions",
                  "description": "Owner permissions from JWT"
                },
                {
                  "name": "$name",
                  "description": "Group name"
                }
              ],
              "returns": "`array{group_id: string, owner_id: string, name: string, created_at: string}`",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [
                "1. Validate name length (1-255 chars using `mb_strlen()`)",
                "2. Verify owner has `groups:manage` permission",
                "3. Generate group ID via `Ids::generateHex32Id()`",
                "4. Create group via `GroupRepository::create([...])`",
                "5. Load created group via `GroupRepository::findById($groupIdHex32)`",
                "6. Emit audit event via `AuditService::emit()` (actor: owner, action: 'groups:create', subject: group)",
                "7. Return group data array"
              ],
              "exception_handling": [],
              "side_effects": null,
              "throws": [
                "ForbiddenException if owner lacks permission",
                "InvalidArgumentException if validation fails"
              ]
            },
            {
              "signature": "listGroups(string $ownerIdHex32, array $ownerPermissions): array",
              "purpose": "List groups owned by an owner",
              "parameters": [
                {
                  "name": "$ownerIdHex32",
                  "description": "Owner ID from JWT (hex32)"
                },
                {
                  "name": "$ownerPermissions",
                  "description": "Owner permissions from JWT"
                }
              ],
              "returns": "`array<array>` List of groups",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [
                "1. Verify owner has `groups:manage` permission",
                "2. Find groups by owner via `GroupRepository::findByOwner($ownerIdHex32)`",
                "3. Return groups array"
              ],
              "exception_handling": [],
              "side_effects": null,
              "throws": [
                "ForbiddenException if owner lacks permission"
              ]
            },
            {
              "signature": "getGroup(string $groupIdHex32, string $ownerIdHex32, array $ownerPermissions): array",
              "purpose": "Get group details",
              "parameters": [
                {
                  "name": "$groupIdHex32",
                  "description": "Group ID (hex32)"
                },
                {
                  "name": "$ownerIdHex32",
                  "description": "Owner ID from JWT (hex32)"
                },
                {
                  "name": "$ownerPermissions",
                  "description": "Owner permissions from JWT"
                }
              ],
              "returns": "`array` Group data",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [
                "1. Verify owner has `groups:manage` permission",
                "2. Load group via `GroupRepository::findById($groupIdHex32)`",
                "3. If group not found, throw NotFoundException",
                "4. Verify group is owned by owner (check `owner_id` matches)",
                "5. If not owned, throw NotFoundException (hide existence)",
                "6. Return group data array"
              ],
              "exception_handling": [],
              "side_effects": null,
              "throws": [
                "NotFoundException if group not found or not owned by owner",
                "ForbiddenException if owner lacks permission"
              ]
            },
            {
              "signature": "renameGroup(string $groupIdHex32, string $ownerIdHex32, array $ownerPermissions, string $name): array",
              "purpose": "Rename a group",
              "parameters": [
                {
                  "name": "$groupIdHex32",
                  "description": "Group ID (hex32)"
                },
                {
                  "name": "$ownerIdHex32",
                  "description": "Owner ID from JWT (hex32)"
                },
                {
                  "name": "$ownerPermissions",
                  "description": "Owner permissions from JWT"
                },
                {
                  "name": "$name",
                  "description": "New name"
                }
              ],
              "returns": "`array{group_id: string, owner_id: string, name: string, updated_at: string}`",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [
                "1. Validate name length (1-255 chars)",
                "2. Verify owner has `groups:manage` permission",
                "3. Load group and verify ownership",
                "4. Update group name via `GroupRepository::updateName($groupIdHex32, $name)`",
                "5. Load updated group via `GroupRepository::findById($groupIdHex32)`",
                "6. Emit audit event via `AuditService::emit()` (actor: owner, action: 'groups:rename', subject: group)",
                "7. Return updated group data array"
              ],
              "exception_handling": [],
              "side_effects": null,
              "throws": [
                "NotFoundException if group not found or not owned by owner",
                "ForbiddenException if owner lacks permission",
                "InvalidArgumentException if validation fails"
              ]
            },
            {
              "signature": "deleteGroup(string $groupIdHex32, string $ownerIdHex32, array $ownerPermissions): void",
              "purpose": "Delete a group",
              "parameters": [
                {
                  "name": "$groupIdHex32",
                  "description": "Group ID (hex32)"
                },
                {
                  "name": "$ownerIdHex32",
                  "description": "Owner ID from JWT (hex32)"
                },
                {
                  "name": "$ownerPermissions",
                  "description": "Owner permissions from JWT"
                }
              ],
              "returns": "void",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [
                "1. Verify owner has `groups:manage` permission",
                "2. Load group and verify ownership",
                "3. Delete group via `GroupRepository::delete($groupIdHex32)` (memberships cascade deleted by DB foreign key)",
                "4. Emit audit event via `AuditService::emit()` (actor: owner, action: 'groups:delete', subject: group)"
              ],
              "exception_handling": [],
              "side_effects": null,
              "throws": [
                "NotFoundException if group not found or not owned by owner",
                "ForbiddenException if owner lacks permission"
              ]
            },
            {
              "signature": "addMember(string $groupIdHex32, string $ownerIdHex32, array $ownerPermissions, string $keyIdHex32): array",
              "purpose": "Add a key to a group",
              "parameters": [
                {
                  "name": "$groupIdHex32",
                  "description": "Group ID (hex32)"
                },
                {
                  "name": "$ownerIdHex32",
                  "description": "Owner ID from JWT (hex32)"
                },
                {
                  "name": "$ownerPermissions",
                  "description": "Owner permissions from JWT"
                },
                {
                  "name": "$keyIdHex32",
                  "description": "Key ID (hex32)"
                }
              ],
              "returns": "`array{group_id: string, key_id: string}`",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [
                "1. Verify owner has `groups:manage` permission",
                "2. Load group and verify ownership",
                "3. Load key and verify ownership (via initial_author_key_id matching owner's primary keys)",
                "4. Check if key is already a member via `GroupMemberRepository::isMember($groupIdHex32, $keyIdHex32)`",
                "5. If already member, return success",
                "6. Add key to group via `GroupMemberRepository::add($groupIdHex32, $keyIdHex32)`",
                "7. Emit audit event via `AuditService::emit()` (actor: owner, action: 'groups:member:add', subject: group)",
                "8. Return membership data array"
              ],
              "exception_handling": [],
              "side_effects": null,
              "throws": [
                "NotFoundException if group or key not found or not owned by owner",
                "ForbiddenException if owner lacks permission"
              ]
            },
            {
              "signature": "removeMember(string $groupIdHex32, string $ownerIdHex32, array $ownerPermissions, string $keyIdHex32): void",
              "purpose": "Remove a key from a group",
              "parameters": [
                {
                  "name": "$groupIdHex32",
                  "description": "Group ID (hex32)"
                },
                {
                  "name": "$ownerIdHex32",
                  "description": "Owner ID from JWT (hex32)"
                },
                {
                  "name": "$ownerPermissions",
                  "description": "Owner permissions from JWT"
                },
                {
                  "name": "$keyIdHex32",
                  "description": "Key ID (hex32)"
                }
              ],
              "returns": "void",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [
                "1. Verify owner has `groups:manage` permission",
                "2. Load group and verify ownership",
                "3. Remove key from group via `GroupMemberRepository::remove($groupIdHex32, $keyIdHex32)`",
                "4. Emit audit event via `AuditService::emit()` (actor: owner, action: 'groups:member:remove', subject: group)"
              ],
              "exception_handling": [],
              "side_effects": null,
              "throws": [
                "NotFoundException if group not found or not owned by owner",
                "ForbiddenException if owner lacks permission"
              ]
            },
            {
              "signature": "listGroupsForKey(string $keyIdHex32, array $keyPermissions): array",
              "purpose": "List groups (Gateway read-only)",
              "parameters": [
                {
                  "name": "$keyIdHex32",
                  "description": "Key ID from JWT (hex32)"
                },
                {
                  "name": "$keyPermissions",
                  "description": "Key permissions from JWT"
                }
              ],
              "returns": "`array<array>` List of groups",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [
                "1. Verify key has `groups:read` permission",
                "2. Load key via `KeyRepository::findById($keyIdHex32)`",
                "3. Get owner ID from key's initial_author_key_id (which is the owner's primary key)",
                "4. Get the primary key to access its owner_id",
                "5. Find groups by owner via `GroupRepository::findByOwner($ownerIdHex32)`",
                "6. Return groups array"
              ],
              "exception_handling": [],
              "side_effects": null,
              "throws": [
                "NotFoundException if key not found",
                "ForbiddenException if key lacks permission"
              ]
            },
            {
              "signature": "getGroupForKey(string $groupIdHex32, string $keyIdHex32, array $keyPermissions): array",
              "purpose": "Get group details (Gateway read-only)",
              "parameters": [
                {
                  "name": "$groupIdHex32",
                  "description": "Group ID (hex32)"
                },
                {
                  "name": "$keyIdHex32",
                  "description": "Key ID from JWT (hex32)"
                },
                {
                  "name": "$keyPermissions",
                  "description": "Key permissions from JWT"
                }
              ],
              "returns": "`array` Group data",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [
                "1. Verify key has `groups:read` permission",
                "2. Load key and get owner ID (via initial_author_key_id → primary key → owner_id)",
                "3. Load group via `GroupRepository::findById($groupIdHex32)`",
                "4. Verify group is owned by key's owner",
                "5. Return group data array"
              ],
              "exception_handling": [],
              "side_effects": null,
              "throws": [
                "NotFoundException if group or key not found or group not owned by key's owner",
                "ForbiddenException if key lacks permission"
              ]
            },
            {
              "signature": "listGroupMembersForKey(string $groupIdHex32, string $keyIdHex32, array $keyPermissions): array",
              "purpose": "List group members (Gateway read-only)",
              "parameters": [
                {
                  "name": "$groupIdHex32",
                  "description": "Group ID (hex32)"
                },
                {
                  "name": "$keyIdHex32",
                  "description": "Key ID from JWT (hex32)"
                },
                {
                  "name": "$keyPermissions",
                  "description": "Key permissions from JWT"
                }
              ],
              "returns": "`array<string>` List of key IDs (hex32)",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [
                "1. Verify key has `groups:read` permission",
                "2. Load key and get owner ID (via initial_author_key_id → primary key → owner_id)",
                "3. Load group and verify ownership",
                "4. Find members of the group via `GroupMemberRepository::findMembers($groupIdHex32)`",
                "5. Return members array (list of key IDs)"
              ],
              "exception_handling": [],
              "side_effects": null,
              "throws": [
                "NotFoundException if group or key not found or group not owned by key's owner",
                "ForbiddenException if key lacks permission"
              ]
            }
          ]
        },
        "2.8_auditservice": {
          "number": "2.8",
          "name": "AuditService",
          "file": "src/Services/AuditService.php",
          "purpose": "Provides a clean interface for emitting audit events across the system",
          "dependencies": [
            "AuditEventRepository",
            "Ids"
          ],
          "methods": [
            {
              "signature": "__construct(AuditEventRepository $auditEventRepository)",
              "purpose": "Initialize service with repository",
              "parameters": [
                {
                  "name": "$auditEventRepository",
                  "description": "Audit event repository"
                }
              ],
              "returns": "void",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [],
              "exception_handling": [],
              "side_effects": "None",
              "throws": []
            },
            {
              "signature": "emit(string $actorType, string $actorIdHex32, string $action, ?string $subjectType = null, ?string $subjectIdHex32 = null, ?array $metadata = null, ?string $ip = null, ?string $userAgent = null): void",
              "purpose": "Extract IP and User-Agent from request",
              "parameters": [
                {
                  "name": "$request",
                  "description": "PSR-7 request (optional)"
                }
              ],
              "returns": "`array{ip: string|null, user_agent: string|null}`",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [
                "1. If request is null, return null values",
                "2. Extract IP from `$request->getServerParams()['REMOTE_ADDR']`",
                "3. Extract User-Agent from `$request->getHeaderLine('User-Agent')`",
                "4. Return array with ip and user_agent"
              ],
              "exception_handling": [],
              "side_effects": "Creates audit event record in database",
              "throws": []
            }
          ]
        },
        "2.9_loggingservice": {
          "number": "2.9",
          "name": "LoggingService",
          "file": "src/Services/LoggingService.php",
          "purpose": "Provides structured JSON logging with Monolog, channel separation, and automatic secret sanitization",
          "dependencies": [
            "SensitiveDataSanitizer",
            "Monolog\\Logger",
            "Monolog\\Handler\\StreamHandler",
            "Monolog\\Formatter\\JsonFormatter"
          ],
          "methods": []
        },
        "2.10_keychainservice": {
          "number": "2.10",
          "name": "KeychainService",
          "file": "src/Services/KeychainService.php",
          "purpose": "Handles keychain management operations for Console and Gateway JSON surfaces",
          "dependencies": [
            "KeychainRepository",
            "KeychainMemberRepository",
            "KeyRepository",
            "AuditService",
            "Ids"
          ],
          "methods": [
            {
              "signature": "__construct(KeychainRepository $keychainRepo, KeychainMemberRepository $keychainMemberRepo, KeyRepository $keyRepo, AuditService $auditService)",
              "purpose": "Initialize service with repositories",
              "parameters": [
                {"name": "$keychainRepo", "description": "Keychain repository"},
                {"name": "$keychainMemberRepo", "description": "Keychain member repository"},
                {"name": "$keyRepo", "description": "Key repository"},
                {"name": "$auditService", "description": "Audit service"}
              ],
              "returns": "void",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [],
              "exception_handling": [],
              "side_effects": "Stores repository references",
              "throws": []
            },
            {
              "signature": "createKeychain(string $ownerIdHex32, array $ownerPermissions, string $name): array",
              "purpose": "Create a new keychain",
              "parameters": [
                {"name": "$ownerIdHex32", "description": "Owner ID from JWT (hex32)"},
                {"name": "$ownerPermissions", "description": "Owner permissions from JWT"},
                {"name": "$name", "description": "Keychain name (1-255 chars)"}
              ],
              "returns": "array{keychain_id: string, owner_id: string, name: string, created_at: string}",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": "keychains:manage",
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [
                "1. Validate name length (1-255 chars)",
                "2. Verify owner has keychains:manage permission",
                "3. Generate keychain ID via Ids::generateHex32Id()",
                "4. Create keychain via KeychainRepository::create()",
                "5. Load and return created keychain",
                "6. Emit audit event via AuditService::emit()"
              ],
              "exception_handling": [
                "ForbiddenException if owner lacks permission",
                "InvalidArgumentException if validation fails"
              ],
              "side_effects": "Creates keychain record, emits audit event",
              "throws": ["ForbiddenException", "InvalidArgumentException"]
            },
            {
              "signature": "listKeychains(string $ownerIdHex32, array $ownerPermissions): array",
              "purpose": "List keychains owned by an owner",
              "parameters": [
                {"name": "$ownerIdHex32", "description": "Owner ID from JWT (hex32)"},
                {"name": "$ownerPermissions", "description": "Owner permissions from JWT"}
              ],
              "returns": "array<array> List of keychains",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": "keychains:manage",
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [
                "1. Verify owner has keychains:manage permission",
                "2. Find keychains by owner via KeychainRepository::findByOwner()",
                "3. Return list"
              ],
              "exception_handling": ["ForbiddenException if owner lacks permission"],
              "side_effects": null,
              "throws": ["ForbiddenException"]
            },
            {
              "signature": "addMember(string $keychainIdHex32, string $ownerIdHex32, array $ownerPermissions, string $keyIdHex32): array",
              "purpose": "Add a key to a keychain",
              "parameters": [
                {"name": "$keychainIdHex32", "description": "Keychain ID (hex32)"},
                {"name": "$ownerIdHex32", "description": "Owner ID from JWT (hex32)"},
                {"name": "$ownerPermissions", "description": "Owner permissions from JWT"},
                {"name": "$keyIdHex32", "description": "Key ID (hex32)"}
              ],
              "returns": "array{keychain_id: string, key_id: string}",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": "keychains:manage",
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [
                "1. Verify owner has keychains:manage permission",
                "2. Load keychain via KeychainRepository::findById() and verify ownership",
                "3. Load key via KeyRepository::findById() and verify ownership (via initial_author_key_id)",
                "4. Add key to keychain via KeychainMemberRepository::add() (idempotent)",
                "5. Emit audit event"
              ],
              "exception_handling": [
                "NotFoundException if keychain/key not found or not owned",
                "ForbiddenException if owner lacks permission"
              ],
              "side_effects": "Creates keychain_members record, emits audit event",
              "throws": ["NotFoundException", "ForbiddenException"]
            },
            {
              "signature": "removeMember(string $keychainIdHex32, string $ownerIdHex32, array $ownerPermissions, string $keyIdHex32): void",
              "purpose": "Remove a key from a keychain",
              "parameters": [
                {"name": "$keychainIdHex32", "description": "Keychain ID (hex32)"},
                {"name": "$ownerIdHex32", "description": "Owner ID from JWT (hex32)"},
                {"name": "$ownerPermissions", "description": "Owner permissions from JWT"},
                {"name": "$keyIdHex32", "description": "Key ID (hex32)"}
              ],
              "returns": "void",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": "keychains:manage",
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [
                "1. Verify owner has keychains:manage permission",
                "2. Load keychain and verify ownership",
                "3. Remove key from keychain via KeychainMemberRepository::remove()",
                "4. Emit audit event"
              ],
              "exception_handling": [
                "NotFoundException if keychain not found or not owned",
                "ForbiddenException if owner lacks permission"
              ],
              "side_effects": "Deletes keychain_members record, emits audit event",
              "throws": ["NotFoundException", "ForbiddenException"]
            },
            {
              "signature": "createExternalKeychain(string $keyIdHex32, array $keyPermissions, string $name): array",
              "purpose": "Create an external keychain (Gateway)",
              "parameters": [
                {"name": "$keyIdHex32", "description": "Key ID from JWT (hex32)"},
                {"name": "$keyPermissions", "description": "Key permissions from JWT"},
                {"name": "$name", "description": "Keychain name (1-255 chars)"}
              ],
              "returns": "array{keychain_id: string, name: string, created_at: string}",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": "keychains:manage",
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [
                "1. Validate name length",
                "2. Verify key has keychains:manage permission",
                "3. Verify key exists via KeyRepository::findById()",
                "4. Generate keychain ID",
                "5. Create external keychain (owner_id = NULL) via KeychainRepository::create()",
                "6. Load and return created keychain",
                "7. Emit audit event"
              ],
              "exception_handling": [
                "NotFoundException if key not found",
                "ForbiddenException if key lacks permission",
                "InvalidArgumentException if validation fails"
              ],
              "side_effects": "Creates keychain record with NULL owner_id, emits audit event",
              "throws": ["NotFoundException", "ForbiddenException", "InvalidArgumentException"]
            },
            {
              "signature": "addMemberToExternalKeychain(string $keychainIdHex32, string $keyIdHex32, array $keyPermissions, string $memberKeyIdHex32): array",
              "purpose": "Add a key to an external keychain (Gateway)",
              "parameters": [
                {"name": "$keychainIdHex32", "description": "Keychain ID (hex32)"},
                {"name": "$keyIdHex32", "description": "Key ID from JWT (hex32)"},
                {"name": "$keyPermissions", "description": "Key permissions from JWT"},
                {"name": "$memberKeyIdHex32", "description": "Member key ID to add (hex32)"}
              ],
              "returns": "array{keychain_id: string, key_id: string}",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": "keychains:manage",
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [
                "1. Verify key has keychains:manage permission",
                "2. Verify key exists",
                "3. Load keychain and verify it's external (owner_id IS NULL)",
                "4. Verify member key exists",
                "5. Add key to keychain (idempotent)",
                "6. Emit audit event"
              ],
              "exception_handling": [
                "NotFoundException if keychain/key not found or keychain is not external",
                "ForbiddenException if key lacks permission"
              ],
              "side_effects": "Creates keychain_members record, emits audit event",
              "throws": ["NotFoundException", "ForbiddenException"]
            },
            {
              "signature": "removeMemberFromExternalKeychain(string $keychainIdHex32, string $keyIdHex32, array $keyPermissions, string $memberKeyIdHex32): void",
              "purpose": "Remove a key from an external keychain (Gateway)",
              "parameters": [
                {"name": "$keychainIdHex32", "description": "Keychain ID (hex32)"},
                {"name": "$keyIdHex32", "description": "Key ID from JWT (hex32)"},
                {"name": "$keyPermissions", "description": "Key permissions from JWT"},
                {"name": "$memberKeyIdHex32", "description": "Member key ID to remove (hex32)"}
              ],
              "returns": "void",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": "keychains:manage",
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [
                "1. Verify key has keychains:manage permission",
                "2. Verify key exists",
                "3. Load keychain and verify it's external",
                "4. Remove key from keychain",
                "5. Emit audit event"
              ],
              "exception_handling": [
                "NotFoundException if keychain/key not found or keychain is not external",
                "ForbiddenException if key lacks permission"
              ],
              "side_effects": "Deletes keychain_members record, emits audit event",
              "throws": ["NotFoundException", "ForbiddenException"]
            }
          ]
        }
      }
    },
    "3_repositories": {
      "number": "3",
      "name": "Repositories",
      "components": {
        "3.1_baserepository": {
          "number": "3.1",
          "name": "BaseRepository",
          "file": "src/Repositories/BaseRepository.php",
          "purpose": "Base class providing PDO instance and ID conversion helpers",
          "dependencies": [
            "\\PDO",
            "App\\Utilities\\Ids"
          ],
          "methods": [
            {
              "signature": "__construct(\\PDO $pdo)",
              "purpose": "Get PDO instance for transaction management",
              "parameters": [
                {
                  "name": "$binary",
                  "description": "Binary ID (16 bytes)"
                }
              ],
              "returns": "`\\PDO` Database connection",
              "uses": "Ids::generateHex32Id()",
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [],
              "exception_handling": [],
              "side_effects": "None",
              "throws": []
            }
          ]
        },
        "3.2_postrepository": {
          "number": "3.2",
          "name": "PostRepository",
          "file": "src/Repositories/PostRepository.php",
          "purpose": "Data access for posts table",
          "dependencies": [
            "BaseRepository",
            "Ids"
          ],
          "methods": [
            {
              "signature": "create(array $data): void",
              "purpose": "Create a new post",
              "parameters": [
                {
                  "name": "$data",
                  "description": "Post data array with keys: `id` (hex32), `author_key_id` (hex32), `initial_author_key_id` (hex32), `title` (string|null), `content` (string)"
                }
              ],
              "returns": "void",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [],
              "exception_handling": [],
              "side_effects": "Creates post record in database",
              "throws": []
            },
            {
              "signature": "findById(string $postIdHex32): ?array",
              "purpose": "Find post by ID",
              "parameters": [
                {
                  "name": "$postIdHex32",
                  "description": "Post ID (hex32)"
                }
              ],
              "returns": "`array|null` Post data with hex32 IDs or null if not found",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [],
              "exception_handling": [],
              "side_effects": null,
              "throws": []
            },
            {
              "signature": "findByAuthor(string $authorKeyIdHex32, int $limit = 20, ?string $beforeIdHex32 = null): array",
              "purpose": "Find posts by author",
              "parameters": [
                {
                  "name": "$authorKeyIdHex32",
                  "description": "Author key ID (hex32)"
                },
                {
                  "name": "$limit",
                  "description": "Limit (default: 20)"
                },
                {
                  "name": "$beforeIdHex32",
                  "description": "Cursor (post ID before this) - optional"
                }
              ],
              "returns": "`array<array>` List of posts (same format as findById)",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [],
              "exception_handling": [],
              "side_effects": null,
              "throws": []
            },
            {
              "signature": "findByOwner(array $primaryKeyIdsHex32, int $limit = 20, ?string $beforeIdHex32 = null): array",
              "purpose": "Find posts by owner (via initial_author_key_id)",
              "parameters": [
                {
                  "name": "$primaryKeyIdsHex32",
                  "description": "Array of owner's primary key IDs (hex32)"
                },
                {
                  "name": "$limit",
                  "description": "Limit (default: 20)"
                },
                {
                  "name": "$beforeIdHex32",
                  "description": "Cursor (post ID before this) - optional"
                }
              ],
              "returns": "`array<array>` List of posts (same format as findById)",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [],
              "exception_handling": [],
              "side_effects": null,
              "throws": []
            },
            {
              "signature": "findVisiblePostsForUseKey(string $keyIdHex32, array $groupIdsHex32, int $limit = 20, ?string $beforeIdHex32 = null, ?string $sinceIdHex32 = null): array",
              "purpose": "Find visible posts for a Use Key (feed query)",
              "parameters": [
                {
                  "name": "$keyIdHex32",
                  "description": "Use Key ID (hex32)"
                },
                {
                  "name": "$groupIdsHex32",
                  "description": "List of group IDs the key belongs to (hex32)"
                },
                {
                  "name": "$limit",
                  "description": "Limit (default 20, max 100)"
                },
                {
                  "name": "$beforeIdHex32",
                  "description": "Cursor for older posts (post ID) - optional"
                },
                {
                  "name": "$sinceIdHex32",
                  "description": "Cursor for newer posts (post ID) - optional"
                }
              ],
              "returns": "`array<array>` List of posts (same format as findById)",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [],
              "exception_handling": [],
              "side_effects": null,
              "throws": []
            },
            {
              "signature": "findByInitialAuthor(string $initialAuthorKeyIdHex32, int $limit = 20, ?string $beforeIdHex32 = null, ?string $sinceIdHex32 = null): array",
              "purpose": "Find posts by initial author (for Author feed)",
              "parameters": [
                {
                  "name": "$initialAuthorKeyIdHex32",
                  "description": "Initial author key ID (hex32)"
                },
                {
                  "name": "$limit",
                  "description": "Limit (default 20, max 100)"
                },
                {
                  "name": "$beforeIdHex32",
                  "description": "Cursor for older posts (post ID) - optional"
                },
                {
                  "name": "$sinceIdHex32",
                  "description": "Cursor for newer posts (post ID) - optional"
                }
              ],
              "returns": "`array<array>` List of posts (same format as findById)",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [],
              "exception_handling": [],
              "side_effects": null,
              "throws": []
            },
            {
              "signature": "findVisiblePostsForGroups(array $groupIdsHex32, int $limit = 20, ?string $beforeIdHex32 = null, ?string $sinceIdHex32 = null): array",
              "purpose": "Find posts visible via group memberships (for Author feed enhancement)",
              "parameters": [
                {
                  "name": "$groupIdsHex32",
                  "description": "List of group IDs (hex32)"
                },
                {
                  "name": "$limit",
                  "description": "Limit (default 20, max 100)"
                },
                {
                  "name": "$beforeIdHex32",
                  "description": "Cursor for older posts (post ID) - optional"
                },
                {
                  "name": "$sinceIdHex32",
                  "description": "Cursor for newer posts (post ID) - optional"
                }
              ],
              "returns": "`array<array>` List of posts (same format as findById)",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [],
              "exception_handling": [],
              "side_effects": null,
              "throws": []
            }
          ]
        },
        "3.3_postaccessrepository": {
          "number": "3.3",
          "name": "PostAccessRepository",
          "file": "src/Repositories/PostAccessRepository.php",
          "purpose": "Data access for post_access table with specialized helpers for access resolution",
          "dependencies": [
            "BaseRepository",
            "Ids"
          ],
          "methods": [
            {
              "signature": "upsert(array $data): void",
              "purpose": "Create or update access grant",
              "parameters": [
                {
                  "name": "$data",
                  "description": "Access grant data array with keys: `id` (hex32), `post_id` (hex32), `target_type` (string), `target_id` (hex32), `permission_mask` (int)"
                }
              ],
              "returns": "void",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [],
              "exception_handling": [],
              "side_effects": "Creates or updates access grant record",
              "throws": []
            },
            {
              "signature": "revoke(string $postIdHex32, string $targetType, string $targetIdHex32): void",
              "purpose": "Revoke access grant",
              "parameters": [
                {
                  "name": "$postIdHex32",
                  "description": "Post ID (hex32)"
                },
                {
                  "name": "$targetType",
                  "description": "Target type ('key' or 'group')"
                },
                {
                  "name": "$targetIdHex32",
                  "description": "Target ID (hex32)"
                }
              ],
              "returns": "void",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [],
              "exception_handling": [],
              "side_effects": "Deletes access grant record",
              "throws": []
            },
            {
              "signature": "findByPost(string $postIdHex32): array",
              "purpose": "Resolve access mask for a key on a post (including group memberships)",
              "parameters": [
                {
                  "name": "$postIdHex32",
                  "description": "Post ID (hex32)"
                },
                {
                  "name": "$keyIdHex32",
                  "description": "Key ID (hex32)"
                },
                {
                  "name": "$groupIdsHex32",
                  "description": "List of group IDs the key belongs to (hex32) - default: []"
                }
              ],
              "returns": "`int` Permission mask (0 if no access)",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [
                "1. Check direct key grant via `findDirectAccess($postIdHex32, $keyIdHex32)`",
                "2. If direct access exists, OR mask with result",
                "3. If group IDs provided, query group grants:"
              ],
              "exception_handling": [],
              "side_effects": null,
              "throws": []
            }
          ]
        },
        "3.4_commentrepository": {
          "number": "3.4",
          "name": "CommentRepository",
          "file": "src/Repositories/CommentRepository.php",
          "purpose": "Data access for comments table",
          "dependencies": [
            "BaseRepository",
            "Ids"
          ],
          "methods": [
            {
              "signature": "create(array $data): void",
              "purpose": "Create a new comment",
              "parameters": [
                {
                  "name": "$data",
                  "description": "Comment data array with keys: `id` (hex32), `post_id` (hex32), `created_by_key_id` (hex32), `body` (string)"
                }
              ],
              "returns": "void",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [],
              "exception_handling": [],
              "side_effects": "Creates comment record in database",
              "throws": []
            },
            {
              "signature": "findById(string $commentIdHex32): ?array",
              "purpose": "Find comment by ID",
              "parameters": [
                {
                  "name": "$commentIdHex32",
                  "description": "Comment ID (hex32)"
                }
              ],
              "returns": "`array|null` Comment data with hex32 IDs or null if not found",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [],
              "exception_handling": [],
              "side_effects": null,
              "throws": []
            },
            {
              "signature": "findByPost(string $postIdHex32, int $limit = 20, ?string $beforeIdHex32 = null): array",
              "purpose": "Find comments by post",
              "parameters": [
                {
                  "name": "$postIdHex32",
                  "description": "Post ID (hex32)"
                },
                {
                  "name": "$limit",
                  "description": "Limit (default: 20)"
                },
                {
                  "name": "$beforeIdHex32",
                  "description": "Cursor (comment ID before this) - optional"
                }
              ],
              "returns": "`array<array>` List of comments (same format as findById)",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [],
              "exception_handling": [],
              "side_effects": null,
              "throws": []
            }
          ]
        },
        "3.5_keyrepository": {
          "number": "3.5",
          "name": "KeyRepository",
          "file": "src/Repositories/KeyRepository.php",
          "purpose": "Data access for keys table",
          "dependencies": [
            "BaseRepository",
            "Ids"
          ],
          "methods": [
            {
              "signature": "create(array $data): void",
              "purpose": "Create a new key",
              "parameters": [
                {
                  "name": "$data",
                  "description": "Key data array with all key fields (see KeyService for structure)"
                }
              ],
              "returns": "void",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [],
              "exception_handling": [],
              "side_effects": "Creates key record in database",
              "throws": []
            },
            {
              "signature": "findById(string $keyIdHex32): ?array",
              "purpose": "Find key by ID",
              "parameters": [
                {
                  "name": "$keyIdHex32",
                  "description": "Key ID (hex32)"
                }
              ],
              "returns": "`array|null` Key data with hex32 IDs or null if not found",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [],
              "exception_handling": [],
              "side_effects": null,
              "throws": []
            },
            {
              "signature": "findByOwner(string $ownerIdHex32): array",
              "purpose": "Find keys by owner (primary keys only)",
              "parameters": [
                {
                  "name": "$ownerIdHex32",
                  "description": "Owner ID (hex32)"
                }
              ],
              "returns": "`array<array>` List of primary keys owned by this owner (same format as findById)",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [],
              "exception_handling": [],
              "side_effects": null,
              "throws": []
            },
            {
              "signature": "findByInitialAuthor(string $initialAuthorKeyIdHex32): array",
              "purpose": "Find keys by initial author",
              "parameters": [
                {
                  "name": "$initialAuthorKeyIdHex32",
                  "description": "Initial author key ID (hex32)"
                }
              ],
              "returns": "`array<array>` List of keys (same format as findById)",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [],
              "exception_handling": [],
              "side_effects": null,
              "throws": []
            },
            {
              "signature": "updateActive(string $keyIdHex32, bool $active): void",
              "purpose": "Update key active status",
              "parameters": [
                {
                  "name": "$keyIdHex32",
                  "description": "Key ID (hex32)"
                },
                {
                  "name": "$active",
                  "description": "Active status (bool)"
                }
              ],
              "returns": "void",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [],
              "exception_handling": [],
              "side_effects": "Updates key active status",
              "throws": []
            },
            {
              "signature": "retire(string $keyIdHex32): void",
              "purpose": "Retire a key",
              "parameters": [
                {
                  "name": "$keyIdHex32",
                  "description": "Key ID (hex32)"
                }
              ],
              "returns": "void",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [],
              "exception_handling": [],
              "side_effects": "Sets retired_at timestamp",
              "throws": []
            },
            {
              "signature": "markRotated(string $keyIdHex32, string $rotatedToIdHex32): void",
              "purpose": "Update rotated_to_id and retired_at for a key",
              "parameters": [
                {
                  "name": "$keyIdHex32",
                  "description": "Key ID (hex32)"
                },
                {
                  "name": "$rotatedToIdHex32",
                  "description": "New key ID that replaced this one (hex32)"
                }
              ],
              "returns": "void",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [],
              "exception_handling": [],
              "side_effects": "Sets rotated_to_id, retired_at, and active=0",
              "throws": []
            },
            {
              "signature": "deactivate(string $keyIdHex32, bool $cascade = false): int",
              "purpose": "Deactivate a key and optionally all its descendants (cascade)",
              "parameters": [
                {
                  "name": "$keyIdHex32",
                  "description": "Key ID (hex32)"
                },
                {
                  "name": "$cascade",
                  "description": "If true, deactivate all descendants recursively (default: false)"
                }
              ],
              "returns": "`int` Number of keys deactivated",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [],
              "exception_handling": [],
              "side_effects": null,
              "throws": []
            },
            {
              "signature": "incrementUseCount(string $keyIdHex32): void",
              "purpose": "Map database row to array with hex32 IDs",
              "parameters": [
                {
                  "name": "$row",
                  "description": "Database row"
                }
              ],
              "returns": "`array<string, mixed>` Mapped array with hex32 IDs",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [
                "1. Convert all binary IDs to hex32",
                "2. Decode permissions_json to array",
                "3. Cast active to bool",
                "4. Include optional fields if present (owner_id, issued_by_key_id, etc.)"
              ],
              "exception_handling": [],
              "side_effects": "Populates `$descendants` array",
              "throws": []
            }
          ]
        },
        "3.6_ownerrepository": {
          "number": "3.6",
          "name": "OwnerRepository",
          "file": "src/Repositories/OwnerRepository.php",
          "purpose": "Data access for owners table",
          "dependencies": [
            "BaseRepository",
            "Ids"
          ],
          "methods": [
            {
              "signature": "create(string $ownerIdHex32, string $email, string $passwordHash): void",
              "purpose": "Create a new owner",
              "parameters": [
                {
                  "name": "$ownerIdHex32",
                  "description": "Owner ID (hex32)"
                },
                {
                  "name": "$email",
                  "description": "Owner email"
                },
                {
                  "name": "$passwordHash",
                  "description": "Argon2id password hash"
                }
              ],
              "returns": "void",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [],
              "exception_handling": [],
              "side_effects": "Creates owner record in database",
              "throws": []
            },
            {
              "signature": "findById(string $ownerIdHex32): ?array",
              "purpose": "Find owner by ID",
              "parameters": [
                {
                  "name": "$ownerIdHex32",
                  "description": "Owner ID (hex32)"
                }
              ],
              "returns": "`array|null` Owner data with hex32 ID or null if not found",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [],
              "exception_handling": [],
              "side_effects": null,
              "throws": []
            },
            {
              "signature": "findByEmail(string $email): ?array",
              "purpose": "Find owner by email",
              "parameters": [
                {
                  "name": "$email",
                  "description": "Owner email"
                }
              ],
              "returns": "`array|null` Owner data with hex32 ID or null if not found (same format as findById)",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [],
              "exception_handling": [],
              "side_effects": null,
              "throws": []
            }
          ]
        },
        "3.7_refreshtokenrepository": {
          "number": "3.7",
          "name": "RefreshTokenRepository",
          "file": "src/Repositories/RefreshTokenRepository.php",
          "purpose": "Data access for refresh_tokens table",
          "dependencies": [
            "BaseRepository",
            "Ids"
          ],
          "methods": [
            {
              "signature": "create(array $data): void",
              "purpose": "Create a new refresh token",
              "parameters": [
                {
                  "name": "$data",
                  "description": "Token data array with keys: `id` (hex32), `subject_type` (string), `subject_id` (hex32), `token_hash` (string, Argon2id), `lookup_hash` (string, SHA-256), `expires_at` (string), `replaced_by_id` (hex32, optional), `ip` (string, optional), `user_agent` (string, optional)"
                }
              ],
              "returns": "void",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [],
              "exception_handling": [],
              "side_effects": "Creates refresh token record in database",
              "throws": []
            },
            {
              "signature": "findByLookupHash(string $lookupHash): ?array",
              "purpose": "Find token by hash (deprecated - use findByLookupHash instead)",
              "parameters": [
                {
                  "name": "$lookupHash",
                  "description": "SHA-256 hash of the refresh token"
                }
              ],
              "returns": "`array|null` Token data or null if not found",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [],
              "exception_handling": [],
              "side_effects": null,
              "throws": []
            },
            {
              "signature": "markRotated(string $tokenIdHex32, string $replacedByIdHex32): void",
              "purpose": "Mark token as rotated",
              "parameters": [
                {
                  "name": "$tokenIdHex32",
                  "description": "Token ID (hex32)"
                },
                {
                  "name": "$replacedByIdHex32",
                  "description": "Replacement token ID (hex32)"
                }
              ],
              "returns": "void",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [],
              "exception_handling": [],
              "side_effects": "Sets rotated_at timestamp and replaced_by_id",
              "throws": []
            },
            {
              "signature": "revoke(string $tokenIdHex32): void",
              "purpose": "Map database row to array with hex32 IDs",
              "parameters": [
                {
                  "name": "$row",
                  "description": "Database row"
                }
              ],
              "returns": "`array<string, mixed>` Mapped array with hex32 IDs",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [
                "1. Convert all binary IDs to hex32",
                "2. Include optional fields if present (replaced_by_id)"
              ],
              "exception_handling": [],
              "side_effects": "Sets revoked_at timestamp",
              "throws": []
            }
          ]
        },
        "3.8_keypublicidrepository": {
          "number": "3.8",
          "name": "KeyPublicIdRepository",
          "file": "src/Repositories/KeyPublicIdRepository.php",
          "purpose": "Data access for key_public_ids table",
          "dependencies": [
            "BaseRepository",
            "Ids"
          ],
          "methods": [
            {
              "signature": "create(string $idHex32, string $keyIdHex32, string $keyPublicId): void",
              "purpose": "Create a new key public ID mapping",
              "parameters": [
                {
                  "name": "$idHex32",
                  "description": "Record ID (hex32)"
                },
                {
                  "name": "$keyIdHex32",
                  "description": "Key ID (hex32)"
                },
                {
                  "name": "$keyPublicId",
                  "description": "Key public ID (apub_...)"
                }
              ],
              "returns": "void",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [],
              "exception_handling": [],
              "side_effects": "Creates key_public_id mapping record",
              "throws": []
            },
            {
              "signature": "findKeyIdByPublicId(string $keyPublicId): ?string",
              "purpose": "Find key ID by public ID",
              "parameters": [
                {
                  "name": "$keyPublicId",
                  "description": "Key public ID (apub_...)"
                }
              ],
              "returns": "`string|null` Key ID (hex32) or null if not found",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [],
              "exception_handling": [],
              "side_effects": null,
              "throws": []
            },
            {
              "signature": "findPublicIdByKeyId(string $keyIdHex32): ?string",
              "purpose": "Find public ID by key ID",
              "parameters": [
                {
                  "name": "$keyIdHex32",
                  "description": "Key ID (hex32)"
                }
              ],
              "returns": "`string|null` Key public ID (apub_...) or null if not found",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [],
              "exception_handling": [],
              "side_effects": null,
              "throws": []
            }
          ]
        },
        "3.9_groupmemberrepository": {
          "number": "3.9",
          "name": "GroupMemberRepository",
          "file": "src/Repositories/GroupMemberRepository.php",
          "purpose": "Data access for group_members table with specialized helpers for membership lookups",
          "dependencies": [
            "BaseRepository",
            "Ids"
          ],
          "methods": [
            {
              "signature": "add(string $groupIdHex32, string $keyIdHex32): void",
              "purpose": "Add key to group",
              "parameters": [
                {
                  "name": "$groupIdHex32",
                  "description": "Group ID (hex32)"
                },
                {
                  "name": "$keyIdHex32",
                  "description": "Key ID (hex32)"
                }
              ],
              "returns": "void",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [],
              "exception_handling": [],
              "side_effects": "Creates group membership record",
              "throws": []
            },
            {
              "signature": "remove(string $groupIdHex32, string $keyIdHex32): void",
              "purpose": "Remove key from group",
              "parameters": [
                {
                  "name": "$groupIdHex32",
                  "description": "Group ID (hex32)"
                },
                {
                  "name": "$keyIdHex32",
                  "description": "Key ID (hex32)"
                }
              ],
              "returns": "void",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [],
              "exception_handling": [],
              "side_effects": "Deletes group membership record",
              "throws": []
            },
            {
              "signature": "findMembers(string $groupIdHex32): array",
              "purpose": "Find groups for a key",
              "parameters": [
                {
                  "name": "$keyIdHex32",
                  "description": "Key ID (hex32)"
                }
              ],
              "returns": "`array<string>` List of group IDs (hex32)",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [],
              "exception_handling": [],
              "side_effects": null,
              "throws": []
            },
            {
              "signature": "isMember(string $groupIdHex32, string $keyIdHex32): bool",
              "purpose": "Check if key is member of group",
              "parameters": [
                {
                  "name": "$groupIdHex32",
                  "description": "Group ID (hex32)"
                },
                {
                  "name": "$keyIdHex32",
                  "description": "Key ID (hex32)"
                }
              ],
              "returns": "`bool` True if key is member of group",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [],
              "exception_handling": [],
              "side_effects": null,
              "throws": []
            }
          ]
        },
        "3.10_keydevicerepository": {
          "number": "3.10",
          "name": "KeyDeviceRepository",
          "file": "src/Repositories/KeyDeviceRepository.php",
          "purpose": "Data access for key_devices table (optional table for device limit tracking)",
          "dependencies": [
            "BaseRepository",
            "Ids"
          ],
          "methods": [
            {
              "signature": "exists(string $keyIdHex32, string $fingerprint): bool",
              "purpose": "Check if a device fingerprint exists for a key",
              "parameters": [
                {
                  "name": "$keyIdHex32",
                  "description": "Key ID (hex32)"
                },
                {
                  "name": "$fingerprint",
                  "description": "Device fingerprint (SHA256 hash)"
                }
              ],
              "returns": "`bool` True if device exists",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [],
              "exception_handling": [],
              "side_effects": null,
              "throws": []
            },
            {
              "signature": "countDistinct(string $keyIdHex32): int",
              "purpose": "Count distinct devices for a key",
              "parameters": [
                {
                  "name": "$keyIdHex32",
                  "description": "Key ID (hex32)"
                }
              ],
              "returns": "`int` Number of distinct devices",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [],
              "exception_handling": [],
              "side_effects": null,
              "throws": []
            },
            {
              "signature": "register(string $keyIdHex32, string $fingerprint): void",
              "purpose": "Register a new device fingerprint for a key",
              "parameters": [
                {
                  "name": "$keyIdHex32",
                  "description": "Key ID (hex32)"
                },
                {
                  "name": "$fingerprint",
                  "description": "Device fingerprint (SHA256 hash)"
                }
              ],
              "returns": "void",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [],
              "exception_handling": [],
              "side_effects": null,
              "throws": []
            }
          ]
        },
        "3.11_auditeventrepository": {
          "number": "3.11",
          "name": "AuditEventRepository",
          "file": "src/Repositories/AuditEventRepository.php",
          "purpose": "Data access for audit_events table",
          "dependencies": [
            "BaseRepository",
            "Ids"
          ],
          "methods": [
            {
              "signature": "create(array $data): void",
              "purpose": "Create a new audit event",
              "parameters": [
                {
                  "name": "$data",
                  "description": "Event data array with keys: `id` (hex32), `actor_type` (string), `actor_id` (hex32), `action` (string), `subject_type` (string, optional), `subject_id` (hex32, optional), `metadata` (array, optional), `ip` (string, optional), `user_agent` (string, optional)"
                }
              ],
              "returns": "void",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [],
              "exception_handling": [],
              "side_effects": "Creates audit event record in database",
              "throws": []
            },
            {
              "signature": "findByActor(string $actorType, string $actorIdHex32, int $limit = 100): array",
              "purpose": "Find events by actor",
              "parameters": [
                {
                  "name": "$actorType",
                  "description": "Actor type ('owner' or 'key')"
                },
                {
                  "name": "$actorIdHex32",
                  "description": "Actor ID (hex32)"
                },
                {
                  "name": "$limit",
                  "description": "Limit (default: 100)"
                }
              ],
              "returns": "`array<array>` List of audit events",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [],
              "exception_handling": [],
              "side_effects": null,
              "throws": []
            },
            {
              "signature": "findBySubject(string $subjectType, string $subjectIdHex32, int $limit = 100): array",
              "purpose": "Map database row to array with hex32 IDs",
              "parameters": [
                {
                  "name": "$row",
                  "description": "Database row"
                }
              ],
              "returns": "`array<string, mixed>` Mapped array with hex32 IDs",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [
                "1. Convert all binary IDs to hex32",
                "2. Decode metadata_json to array (if present)",
                "3. Include optional fields if present (subject_type, subject_id, metadata)"
              ],
              "exception_handling": [],
              "side_effects": null,
              "throws": []
            }
          ]
        },
        "3.12_grouprepository": {
          "number": "3.12",
          "name": "GroupRepository",
          "file": "src/Repositories/GroupRepository.php",
          "purpose": "Data access for groups table",
          "dependencies": ["PDO", "Ids"],
          "methods": [
            {
              "signature": "create(array $data): void",
              "purpose": "Create a new group",
              "parameters": [{"name": "$data", "description": "Group data with id, owner_id, name"}],
              "returns": "void",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": ["1. Convert hex32 IDs to binary via Ids::hex32ToBinary()", "2. Insert into groups table"],
              "exception_handling": [],
              "side_effects": "Creates group record",
              "throws": []
            },
            {
              "signature": "findById(string $groupIdHex32): ?array",
              "purpose": "Find group by ID",
              "parameters": [{"name": "$groupIdHex32", "description": "Group ID (hex32)"}],
              "returns": "array|null Group data or null if not found",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": ["1. Convert hex32 to binary", "2. Query groups table", "3. Convert binary IDs to hex32 via Ids::binaryToHex32()"],
              "exception_handling": [],
              "side_effects": null,
              "throws": []
            },
            {
              "signature": "findByOwner(string $ownerIdHex32): array",
              "purpose": "Find groups by owner",
              "parameters": [{"name": "$ownerIdHex32", "description": "Owner ID (hex32)"}],
              "returns": "array<array> List of groups",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": ["1. Convert hex32 to binary", "2. Query groups table ORDER BY name", "3. Convert results to hex32"],
              "exception_handling": [],
              "side_effects": null,
              "throws": []
            },
            {
              "signature": "updateName(string $groupIdHex32, string $name): void",
              "purpose": "Update group name",
              "parameters": [
                {"name": "$groupIdHex32", "description": "Group ID (hex32)"},
                {"name": "$name", "description": "New name"}
              ],
              "returns": "void",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": ["1. Convert hex32 to binary", "2. Update groups table"],
              "exception_handling": [],
              "side_effects": "Updates group record",
              "throws": []
            },
            {
              "signature": "delete(string $groupIdHex32): void",
              "purpose": "Delete group",
              "parameters": [{"name": "$groupIdHex32", "description": "Group ID (hex32)"}],
              "returns": "void",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": ["1. Convert hex32 to binary", "2. Delete from groups table"],
              "exception_handling": [],
              "side_effects": "Deletes group record",
              "throws": []
            }
          ]
        },
        "3.13_keychainrepository": {
          "number": "3.13",
          "name": "KeychainRepository",
          "file": "src/Repositories/KeychainRepository.php",
          "purpose": "Data access for keychains table",
          "dependencies": ["PDO", "Ids"],
          "methods": [
            {
              "signature": "create(array $data): void",
              "purpose": "Create a new keychain",
              "parameters": [{"name": "$data", "description": "Keychain data with id, name, optional owner_id"}],
              "returns": "void",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": ["1. Convert hex32 IDs to binary (if owner_id present)", "2. Insert into keychains table"],
              "exception_handling": [],
              "side_effects": "Creates keychain record",
              "throws": []
            },
            {
              "signature": "findById(string $keychainIdHex32): ?array",
              "purpose": "Find keychain by ID",
              "parameters": [{"name": "$keychainIdHex32", "description": "Keychain ID (hex32)"}],
              "returns": "array|null Keychain data or null if not found",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": ["1. Convert hex32 to binary", "2. Query keychains table", "3. Convert binary IDs to hex32 (if owner_id present)"],
              "exception_handling": [],
              "side_effects": null,
              "throws": []
            },
            {
              "signature": "findByOwner(string $ownerIdHex32): array",
              "purpose": "Find keychains by owner",
              "parameters": [{"name": "$ownerIdHex32", "description": "Owner ID (hex32)"}],
              "returns": "array<array> List of keychains",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": ["1. Convert hex32 to binary", "2. Query keychains table ORDER BY name", "3. Convert results to hex32"],
              "exception_handling": [],
              "side_effects": null,
              "throws": []
            },
            {
              "signature": "findExternal(): array",
              "purpose": "Find external keychains (owner_id IS NULL)",
              "parameters": [],
              "returns": "array<array> List of external keychains",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": ["1. Query keychains table where owner_id IS NULL ORDER BY name", "2. Convert results to hex32"],
              "exception_handling": [],
              "side_effects": null,
              "throws": []
            }
          ]
        },
        "3.14_keychainmemberrepository": {
          "number": "3.14",
          "name": "KeychainMemberRepository",
          "file": "src/Repositories/KeychainMemberRepository.php",
          "purpose": "Data access for keychain_members table",
          "dependencies": ["PDO", "Ids"],
          "methods": [
            {
              "signature": "add(string $keychainIdHex32, string $keyIdHex32): void",
              "purpose": "Add key to keychain",
              "parameters": [
                {"name": "$keychainIdHex32", "description": "Keychain ID (hex32)"},
                {"name": "$keyIdHex32", "description": "Key ID (hex32)"}
              ],
              "returns": "void",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": ["1. Convert hex32 IDs to binary", "2. Insert into keychain_members table"],
              "exception_handling": [],
              "side_effects": "Creates keychain_members record",
              "throws": []
            },
            {
              "signature": "remove(string $keychainIdHex32, string $keyIdHex32): void",
              "purpose": "Remove key from keychain",
              "parameters": [
                {"name": "$keychainIdHex32", "description": "Keychain ID (hex32)"},
                {"name": "$keyIdHex32", "description": "Key ID (hex32)"}
              ],
              "returns": "void",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": ["1. Convert hex32 IDs to binary", "2. Delete from keychain_members table"],
              "exception_handling": [],
              "side_effects": "Deletes keychain_members record",
              "throws": []
            },
            {
              "signature": "findMembers(string $keychainIdHex32): array",
              "purpose": "Find members of a keychain",
              "parameters": [{"name": "$keychainIdHex32", "description": "Keychain ID (hex32)"}],
              "returns": "array<string> List of key IDs (hex32)",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": ["1. Convert hex32 to binary", "2. Query keychain_members table", "3. Convert results to hex32"],
              "exception_handling": [],
              "side_effects": null,
              "throws": []
            }
          ]
        }
      }
    },
    "4_middleware": {
      "number": "4",
      "name": "Middleware",
      "components": {
        "4.1_jwtkeymiddleware": {
          "number": "4.1",
          "name": "JwtKeyMiddleware",
          "file": "src/Middleware/JwtKeyMiddleware.php",
          "purpose": "Verifies Key JWT tokens and enforces typ=key",
          "dependencies": [
            "ResponseFactoryInterface",
            "JwtService",
            "LoggerInterface",
            "ErrorFactory",
            "LoggingService"
          ],
          "methods": [
            {
              "signature": "__construct(ResponseFactoryInterface $responseFactory, JwtService $jwtService, string $expectedAudience, ?LoggerInterface $logger = null)",
              "purpose": "Initialize middleware",
              "parameters": [
                {
                  "name": "$responseFactory",
                  "description": "PSR-7 response factory"
                },
                {
                  "name": "$jwtService",
                  "description": "JWT service for verification"
                },
                {
                  "name": "$expectedAudience",
                  "description": "Expected audience claim (e.g., '/api')"
                },
                {
                  "name": "$logger",
                  "description": "Optional logger for auth channel"
                }
              ],
              "returns": "void",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [],
              "exception_handling": [],
              "side_effects": null,
              "throws": []
            },
            {
              "signature": "process(ServerRequestInterface $request, RequestHandlerInterface $handler): ResponseInterface",
              "purpose": "Process request and verify Key JWT",
              "parameters": [],
              "returns": "`ResponseInterface` (200 OK if successful, 401 if auth fails)",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [
                "1. Extract Bearer token from Authorization header",
                "2. If missing or invalid format, return 401 Unauthorized",
                "3. Verify JWT via `JwtService::verify($token, 'key')` - enforces typ=key",
                "4. Verify audience matches expected audience",
                "5. Extract `key_id`, `roles`, `permissions` from payload",
                "6. Attach to request attributes: `key_id`, `roles`, `permissions`",
                "7. Log authentication success (INFO level)",
                "8. Call handler"
              ],
              "exception_handling": [
                "ExpiredException → 401 Unauthorized with \"Token expired\"",
                "BeforeValidException → 401 Unauthorized with \"Token not yet valid\"",
                "InvalidArgumentException → 401 Unauthorized with \"Invalid token\""
              ],
              "side_effects": "Logs authentication events to auth channel",
              "throws": []
            }
          ]
        },
        "4.2_jwtownermiddleware": {
          "number": "4.2",
          "name": "JwtOwnerMiddleware",
          "file": "src/Middleware/JwtOwnerMiddleware.php",
          "purpose": "Verifies Owner JWT tokens and enforces typ=owner",
          "dependencies": [
            "ResponseFactoryInterface",
            "JwtService",
            "LoggerInterface",
            "ErrorFactory",
            "LoggingService"
          ],
          "methods": [
            {
              "signature": "__construct(ResponseFactoryInterface $responseFactory, JwtService $jwtService, string $expectedAudience, ?LoggerInterface $logger = null)",
              "purpose": "Initialize middleware",
              "parameters": [
                {
                  "name": "$responseFactory",
                  "description": "PSR-7 response factory"
                },
                {
                  "name": "$jwtService",
                  "description": "JWT service for verification"
                },
                {
                  "name": "$expectedAudience",
                  "description": "Expected audience claim (e.g., '/console')"
                },
                {
                  "name": "$logger",
                  "description": "Optional logger for auth channel"
                }
              ],
              "returns": "void",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [],
              "exception_handling": [],
              "side_effects": null,
              "throws": []
            },
            {
              "signature": "process(ServerRequestInterface $request, RequestHandlerInterface $handler): ResponseInterface",
              "purpose": "Process request and verify Owner JWT",
              "parameters": [],
              "returns": "`ResponseInterface` (200 OK if successful, 401 if auth fails)",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [
                "1. Extract Bearer token from Authorization header",
                "2. If missing or invalid format, return 401 Unauthorized",
                "3. Verify JWT via `JwtService::verify($token, 'owner')` - enforces typ=owner",
                "4. Verify audience matches expected audience",
                "5. Extract `owner_id`, `roles`, `permissions` from payload",
                "6. Attach to request attributes: `owner_id`, `roles`, `permissions`",
                "7. Log authentication success (INFO level)",
                "8. Call handler"
              ],
              "exception_handling": [],
              "side_effects": "Logs authentication events to auth channel",
              "throws": []
            }
          ]
        },
        "4.3_validationmiddleware": {
          "number": "4.3",
          "name": "ValidationMiddleware",
          "file": "src/Middleware/ValidationMiddleware.php",
          "purpose": "Validates request body and query parameters using Respect\\Validation",
          "dependencies": [
            "ResponseFactoryInterface",
            "array",
            "ErrorFactory"
          ],
          "methods": [
            {
              "signature": "__construct(ResponseFactoryInterface $responseFactory, array $validationRules)",
              "purpose": "Initialize middleware with validation rules",
              "parameters": [
                {
                  "name": "$responseFactory",
                  "description": "PSR-7 response factory"
                },
                {
                  "name": "$validationRules",
                  "description": "Validation rules array (method => path pattern => rules)"
                }
              ],
              "returns": "void",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [],
              "exception_handling": [],
              "side_effects": null,
              "throws": []
            },
            {
              "signature": "process(ServerRequestInterface $request, RequestHandlerInterface $handler): ResponseInterface",
              "purpose": "Process request and validate input",
              "parameters": [],
              "returns": "`ResponseInterface` (200 OK if valid, 422 if validation fails)",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [
                "1. Get request method and path",
                "2. Find matching validation rules for method + path pattern",
                "3. Parse request body (JSON) or query parameters",
                "4. Validate each field using Respect\\Validation rules",
                "5. If validation fails, return 422 Unprocessable Entity with error details",
                "6. Call handler"
              ],
              "exception_handling": [],
              "side_effects": "None",
              "throws": []
            }
          ]
        },
        "4.4_errorhandlingmiddleware": {
          "number": "4.4",
          "name": "ErrorHandlingMiddleware",
          "file": "src/Middleware/ErrorHandlingMiddleware.php",
          "purpose": "Catches exceptions and converts them to JSON error responses",
          "dependencies": [
            "ResponseFactoryInterface",
            "LoggerInterface",
            "ErrorFactory",
            "LoggingService"
          ],
          "methods": [
            {
              "signature": "__construct(ResponseFactoryInterface $responseFactory, ?LoggerInterface $logger = null)",
              "purpose": "Initialize middleware",
              "parameters": [
                {
                  "name": "$responseFactory",
                  "description": "PSR-7 response factory"
                },
                {
                  "name": "$logger",
                  "description": "Optional logger for api channel"
                }
              ],
              "returns": "void",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [],
              "exception_handling": [],
              "side_effects": null,
              "throws": []
            },
            {
              "signature": "process(ServerRequestInterface $request, RequestHandlerInterface $handler): ResponseInterface",
              "purpose": "Process request and handle exceptions",
              "parameters": [],
              "returns": "`ResponseInterface` (200 OK if no exception, error response if exception)",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [
                "1. Wrap handler call in try-catch",
                "2. If exception thrown:"
              ],
              "exception_handling": [],
              "side_effects": "Logs exceptions to api channel",
              "throws": []
            }
          ]
        },
        "4.5_ratelimitmiddleware": {
          "number": "4.5",
          "name": "RateLimitMiddleware",
          "file": "src/Middleware/RateLimitMiddleware.php",
          "purpose": "Throttles requests using Symfony rate limiter",
          "dependencies": [
            "ResponseFactoryInterface",
            "RateLimiterFactory",
            "LoggerInterface",
            "ErrorFactory",
            "LoggingService"
          ],
          "methods": [
            {
              "signature": "__construct(ResponseFactoryInterface $responseFactory, RateLimiterFactory $generalLimiter, RateLimiterFactory $authLimiter, RateLimiterFactory $apiLimiter, RateLimiterFactory $consoleLimiter, ?LoggerInterface $logger = null)",
              "purpose": "Initialize middleware with rate limiters",
              "parameters": [],
              "returns": "void",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [],
              "exception_handling": [],
              "side_effects": null,
              "throws": []
            },
            {
              "signature": "process(ServerRequestInterface $request, RequestHandlerInterface $handler): ResponseInterface",
              "purpose": "Process request and apply rate limiting",
              "parameters": [],
              "returns": "`ResponseInterface` (200 OK if within limit, 429 if exceeded)",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [
                "1. Determine bucket based on route path:"
              ],
              "exception_handling": [],
              "side_effects": "Logs rate limit violations to security channel",
              "throws": []
            }
          ]
        },
        "4.6_usekeylimitmiddleware": {
          "number": "4.6",
          "name": "UseKeyLimitMiddleware",
          "file": "src/Middleware/UseKeyLimitMiddleware.php",
          "purpose": "Enforces use_count_limit and device_limit for Use Keys on every API request",
          "dependencies": [
            "ResponseFactoryInterface",
            "KeyRepository",
            "KeyDeviceRepository",
            "ErrorFactory"
          ],
          "methods": [
            {
              "signature": "__construct(ResponseFactoryInterface $responseFactory, KeyRepository $keyRepository, KeyDeviceRepository $keyDeviceRepository)",
              "purpose": "Initialize middleware",
              "parameters": [],
              "returns": "void",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [],
              "exception_handling": [],
              "side_effects": null,
              "throws": []
            },
            {
              "signature": "process(ServerRequestInterface $request, RequestHandlerInterface $handler): ResponseInterface",
              "purpose": "Process request and enforce use key limits",
              "parameters": [],
              "returns": "`ResponseInterface` (200 OK if within limits, 403 if exceeded)",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [
                "1. Get `key_id` from request attributes (set by JwtKeyMiddleware)",
                "2. If no key_id, pass through (not a key-authenticated request)",
                "3. Load key via `KeyRepository::findById($keyIdHex32)`",
                "4. If key not found or not Use Key, pass through",
                "5. **Enforce use_count_limit:**"
              ],
              "exception_handling": [],
              "side_effects": "Increments use_count_current, registers new devices",
              "throws": []
            }
          ]
        },
        "4.7_requestloggingmiddleware": {
          "number": "4.7",
          "name": "RequestLoggingMiddleware",
          "file": "src/Middleware/RequestLoggingMiddleware.php",
          "purpose": "Logs request/response summaries to the 'api' channel with structured JSON",
          "dependencies": [
            "LoggerInterface",
            "LoggingService",
            "Ids"
          ],
          "methods": [
            {
              "signature": "__construct(LoggerInterface $apiLogger)",
              "purpose": "Initialize middleware with api logger",
              "parameters": [
                {
                  "name": "$apiLogger",
                  "description": "Logger instance for api channel"
                }
              ],
              "returns": "void",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [],
              "exception_handling": [],
              "side_effects": null,
              "throws": []
            },
            {
              "signature": "process(ServerRequestInterface $request, RequestHandlerInterface $handler): ResponseInterface",
              "purpose": "Process request and log summary",
              "parameters": [],
              "returns": "`ResponseInterface` (unchanged)",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [
                "1. Record start time",
                "2. Generate or get request_id from request attributes",
                "3. Call handler",
                "4. Calculate latency (ms)",
                "5. Extract authentication context (owner_id or key_id)",
                "6. Build log context:"
              ],
              "exception_handling": [],
              "side_effects": "Writes log entry to api.log",
              "throws": []
            }
          ]
        },
        "4.8_routeparametervalidatormiddleware": {
          "number": "4.8",
          "name": "RouteParameterValidatorMiddleware",
          "file": "src/Middleware/RouteParameterValidatorMiddleware.php",
          "purpose": "Validates route parameters to ensure correct ID format",
          "dependencies": [
            "ResponseFactoryInterface",
            "Ids",
            "ErrorFactory"
          ],
          "methods": [
            {
              "signature": "__construct(ResponseFactoryInterface $responseFactory)",
              "purpose": "Initialize middleware",
              "parameters": [
                {
                  "name": "$responseFactory",
                  "description": "PSR-7 response factory"
                }
              ],
              "returns": "void",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [],
              "exception_handling": [],
              "side_effects": null,
              "throws": []
            },
            {
              "signature": "process(ServerRequestInterface $request, RequestHandlerInterface $handler): ResponseInterface",
              "purpose": "Process request and validate route parameters",
              "parameters": [],
              "returns": "`ResponseInterface` (200 OK if valid, 400 if invalid)",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [
                "1. Get route parameters from request attributes",
                "2. For each parameter:"
              ],
              "exception_handling": [],
              "side_effects": "None",
              "throws": []
            }
          ]
        },
        "4.9_httpsmiddleware": {
          "number": "4.9",
          "name": "HttpsMiddleware",
          "file": "src/Middleware/HttpsMiddleware.php",
          "purpose": "Enforces HTTPS and applies HSTS headers",
          "dependencies": [],
          "methods": [
            {
              "signature": "process(ServerRequestInterface $request, RequestHandlerInterface $handler): ResponseInterface",
              "purpose": "Process request and enforce HTTPS",
              "parameters": [],
              "returns": "`ResponseInterface` (200 OK or 301 redirect)",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [
                "1. Check if request is HTTPS (scheme or X-Forwarded-Proto header)",
                "2. If not HTTPS and in production, redirect to HTTPS (301)",
                "3. Call handler",
                "4. If HTTPS and in production, add HSTS header (max-age=31536000; includeSubDomains)"
              ],
              "exception_handling": [],
              "side_effects": "Adds HSTS header to response",
              "throws": []
            }
          ]
        },
        "4.10_corsmiddleware": {
          "number": "4.10",
          "name": "CorsMiddleware",
          "file": "src/Middleware/CorsMiddleware.php",
          "purpose": "Applies Cross-Origin Resource Sharing headers based on environment configuration",
          "dependencies": [],
          "methods": [
            {
              "signature": "__construct()",
              "purpose": "Initialize middleware with CORS configuration",
              "parameters": [],
              "returns": "void",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [
                "1. Parse `CORS_ALLOWED_ORIGINS` (comma-separated)",
                "2. Parse `CORS_ALLOWED_METHODS` (default: GET,POST,PUT,PATCH,DELETE,OPTIONS)",
                "3. Parse `CORS_ALLOWED_HEADERS` (default: Authorization,Content-Type)",
                "4. Parse `CORS_EXPOSED_HEADERS` (comma-separated)"
              ],
              "exception_handling": [],
              "side_effects": null,
              "throws": []
            },
            {
              "signature": "process(ServerRequestInterface $request, RequestHandlerInterface $handler): ResponseInterface",
              "purpose": "Process request and apply CORS headers",
              "parameters": [],
              "returns": "`ResponseInterface` (200 OK or 204 for preflight)",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [
                "1. Get Origin header",
                "2. If OPTIONS request (preflight), return 204 with CORS headers",
                "3. Call handler",
                "4. Add CORS headers to response:"
              ],
              "exception_handling": [],
              "side_effects": "Adds CORS headers to response",
              "throws": []
            }
          ]
        },
        "4.11_cspmiddleware": {
          "number": "4.11",
          "name": "CspMiddleware",
          "file": "src/Middleware/CspMiddleware.php",
          "purpose": "Applies Content Security Policy headers to HTML responses only",
          "dependencies": [],
          "methods": [
            {
              "signature": "__construct()",
              "purpose": "Initialize middleware with CSP configuration",
              "parameters": [],
              "returns": "void",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [
                "1. Get `CSP_DEFAULT_SRC` from environment (default: 'self')"
              ],
              "exception_handling": [],
              "side_effects": null,
              "throws": []
            },
            {
              "signature": "process(ServerRequestInterface $request, RequestHandlerInterface $handler): ResponseInterface",
              "purpose": "Process request and apply CSP headers",
              "parameters": [],
              "returns": "`ResponseInterface` (unchanged)",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [
                "1. Call handler",
                "2. Check Content-Type header",
                "3. If Content-Type is text/html, add Content-Security-Policy header",
                "4. CSP value: `default-src {CSP_DEFAULT_SRC}`"
              ],
              "exception_handling": [],
              "side_effects": "Adds CSP header to HTML responses only",
              "throws": []
            }
          ]
        },
        "4.12_csrfexposemiddleware": {
          "number": "4.12",
          "name": "CsrfExposeMiddleware",
          "file": "src/Middleware/CsrfExposeMiddleware.php",
          "purpose": "Exposes CSRF tokens as request attributes and response headers",
          "dependencies": [],
          "methods": [
            {
              "signature": "process(ServerRequestInterface $request, RequestHandlerInterface $handler): ResponseInterface",
              "purpose": "Process request and expose CSRF tokens",
              "parameters": [],
              "returns": "`ResponseInterface` (unchanged)",
              "uses": null,
              "endpoint": null,
              "auth": null,
              "required_permission": null,
              "required_mask": null,
              "request_attributes_used": [],
              "route_parameters": [],
              "request_body_expected": [],
              "query_parameters": [],
              "process": [
                "1. Call handler",
                "2. Get CSRF tokens from request attributes (set by Slim\\Csrf\\Guard):"
              ],
              "exception_handling": [],
              "side_effects": "Adds CSRF headers to response",
              "throws": []
            }
          ]
        }
      }
    },
    "5_security_components": {
      "number": "5",
      "name": "Security Components",
      "components": {
        "5.1_jwtservice": {
          "number": "5.1",
          "name": "JwtService",
          "file": "src/Security/JwtService.php",
          "purpose": "Handles JWT signing and verification using RS256",
          "dependencies": [
            "LoggerInterface",
            "firebase/php-jwt"
          ],
          "methods": []
        },
        "5.2_permissioncatalog": {
          "number": "5.2",
          "name": "PermissionCatalog",
          "file": "src/Security/PermissionCatalog.php",
          "purpose": "Defines global permission strings, roles, and validation logic",
          "dependencies": [],
          "methods": []
        },
        "5.3_postaccessbitmask": {
          "number": "5.3",
          "name": "PostAccessBitmask",
          "file": "src/Security/PostAccessBitmask.php",
          "purpose": "Defines constants and helpers for post-specific access control bitmasks",
          "dependencies": [],
          "methods": []
        }
      }
    },
    "6_utilities": {
      "number": "6",
      "name": "Utilities",
      "components": {
        "6.1_ids": {
          "number": "6.1",
          "name": "Ids",
          "file": "src/Utilities/Ids.php",
          "purpose": "Utility for converting between internal BINARY(16) and external hex32 IDs",
          "dependencies": [],
          "methods": []
        },
        "6.2_responsefactory": {
          "number": "6.2",
          "name": "ResponseFactory",
          "file": "src/Utilities/ResponseFactory.php",
          "purpose": "Utility for creating standardized JSON success responses",
          "dependencies": [],
          "methods": []
        },
        "6.3_errorfactory": {
          "number": "6.3",
          "name": "ErrorFactory",
          "file": "src/Utilities/ErrorFactory.php",
          "purpose": "Utility for creating standardized JSON error responses",
          "dependencies": [],
          "methods": []
        },
        "6.4_sensitivedatasanitizer": {
          "number": "6.4",
          "name": "SensitiveDataSanitizer",
          "file": "src/Utilities/SensitiveDataSanitizer.php",
          "purpose": "Utility for redacting sensitive information from arrays before logging",
          "dependencies": [],
          "methods": []
        },
        "6.5_bootstrapvalidator": {
          "number": "6.5",
          "name": "BootstrapValidator",
          "file": "src/Utilities/BootstrapValidator.php",
          "purpose": "Utility for performing fail-fast validation of environment configuration",
          "dependencies": [],
          "methods": []
        }
      }
    },
    "7_exceptions": {
      "number": "7",
      "name": "Exceptions",
      "components": {
        "7.1_notfoundexception": {
          "number": "7.1",
          "name": "NotFoundException",
          "file": "src/Exceptions/NotFoundException.php",
          "purpose": "Custom exception for 404 responses",
          "dependencies": [],
          "methods": []
        },
        "7.2_forbiddenexception": {
          "number": "7.2",
          "name": "ForbiddenException",
          "file": "src/Exceptions/ForbiddenException.php",
          "purpose": "Custom exception for 403 responses",
          "dependencies": [],
          "methods": []
        }
      }
    },
    "8_route_definitions": {
      "number": "8",
      "name": "Route Definitions",
      "components": {
        "8.1_route_groups": {
          "number": "8.1",
          "name": "Route Groups",
          "file": "config/routes.php",
          "purpose": null,
          "dependencies": [],
          "methods": []
        }
      }
    },
    "9_database_migrations": {
      "number": "9",
      "name": "Database Migrations",
      "components": {
        "9.1_migration_structure": {
          "number": "9.1",
          "name": "Migration Structure",
          "file": null,
          "purpose": null,
          "dependencies": [],
          "methods": []
        }
      }
    },
    "10_configuration_files": {
      "number": "10",
      "name": "Configuration Files",
      "components": {
        "10.1_bootstrap": {
          "number": "10.1",
          "name": "Bootstrap",
          "file": "src/bootstrap.php",
          "purpose": "Application bootstrap - loads environment, validates config, builds DI container",
          "dependencies": [],
          "methods": []
        },
        "10.2_container_configuration": {
          "number": "10.2",
          "name": "Container Configuration",
          "file": "config/container.php",
          "purpose": "PHP-DI container configuration",
          "dependencies": [],
          "methods": []
        },
        "10.3_route_configuration": {
          "number": "10.3",
          "name": "Route Configuration",
          "file": "config/routes.php",
          "purpose": "Route registration and middleware pipeline configuration",
          "dependencies": [],
          "methods": []
        },
        "10.4_validation_configuration": {
          "number": "10.4",
          "name": "Validation Configuration",
          "file": "config/validation.php",
          "purpose": "Centralized input validation rules",
          "dependencies": [],
          "methods": []
        }
      }
    }
  }
}